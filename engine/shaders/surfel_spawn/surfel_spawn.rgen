//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define RT_DESCRIPTOR_SET 0
#include "../rt_descriptor_set.glsl"

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

#define STATUS_DESCRIPTOR_SET 2
#include "../status.glsl"

// discovered and bvh fields are readonly (and discovered is unused)
#define BVH_IS_READONLY
#define DISCOVERED_IS_READONLY
#define SURFELS_DESCRIPTOR_SET 3
#include "../surfel.glsl"

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define DEPTH_IGNORE 1.0

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    // surfels needs to be spawned just once per reusable frame
    if (gi_data.gi_reuse_frames >= 2) {
        return;
    }

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;
    const vec3 specular = texelFetch(gbuffer[3], texel_position, 0).xyz;
    const float depth = texture(gbuffer_depth, vec3(float(texel_position.x) / float(resolution.x), float(texel_position.y) / float(resolution.y), 1.0));

    const uvec4 instance_data = texelFetch(gbuffer_instance_id, texel_position, 0);
    const uint mesh_id = instance_data.x;
    const uint instance_id = instance_data.y;

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();
    const vec3 view_dir = normalize(eye_position - origin);

    // debug print of discovered surfels
    //if (texel_position == ivec2(0, 0)) {
    //    debugPrintfEXT("clip planes: %f %f\n", clip_planes.x, clip_planes.y);
    //    debugPrintfEXT("Number of discovered surfels: %u\n", count_discoveder_surfels());
    //}

    // Do nothing if there is nothing rendered on the pixel
    if ((depth >= DEPTH_IGNORE) || (mesh_id == 0xFFFFFFFFu) || (instance_id == 0xFFFFFFFFu)) {
        return;
    }

    // direct lighting: only compute it if the previous GI data cannot be reused
    vec3 surfel_received_direction_light = vec3(0.0);
    if ((gi_data.gi_reuse_frames == 0) && (depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        vec3 lights_contribution = vec3(0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) < 0.4) {
                continue;
            }

            // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                0xff,
                0,
                0,
                0,
                origin.xyz,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_dir.xyz,
                10000.0,
                0
            );

            if (!payload.hit) {
                diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                const vec3 diffuse_component = diffuse_contribution * light_intensity * diffuse;

                const vec3 reflect_dir = reflect(-light_dir, normal);
                specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                const vec3 specular = specular_contribution * light_intensity * specular;

                // TODO: here sum specular
                lights_contribution += diffuse_component;

                // data for the surfel that will be spawned: accumulate incoming light:
                // DO NOT account for surface properties
                surfel_received_direction_light += diffuse_contribution * light_intensity;
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }

    // try to allocate a new surfel (or get the ID of an existing one)
    bool fresh_allocation = false;
    const uint surfel_id = find_surfel_or_allocate_new(
        eye_position,
        clip_planes,
        instance_id,
        origin,
        normal,
        diffuse,
        true,
        fresh_allocation
    );

    if (!IS_SURFEL_VALID(surfel_id)) {
        return;
    }

    // as a rule globally valid it is the surfel spawner's responsibility
    // to calculate directional light contribution to the surfel.
    if (fresh_allocation) {
        // Register incoming directional lighting to the surfel
        addDirectionalLightContribution(surfel_id, surfel_received_direction_light);

        unlock_surfel(surfel_id);
        memoryBarrierBuffer();
    } else {
        if (lock_surfel(surfel_id)) {
            // update the last time the surfel was used
            surfels[surfel_id].latest_contribution = 0;

            unlock_surfel(surfel_id);
            memoryBarrierBuffer();
        }
    }
    
}
