#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

#define SURFELS_DESCRIPTOR_SET 2
#include "../surfel.glsl"

// Keep in sync with SURFELS_DISCOVERY_GROUP_SIZE_X and SURFELS_DISCOVERY_GROUP_SIZE_Y
layout (local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_GlobalInvocationID.xy);

    // avoid checking out-of-bounds
    if (any(greaterThanEqual(texel_position, resolution))) {
        return;
    }

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;

    const uvec4 instance_data = texelFetch(gbuffer_instance_id, texel_position, 0);
    const uint mesh_id = instance_data.x;
    const uint instance_id = instance_data.y;

    if (mesh_id == 0xFFFFFFFFu) {
        // no geometry here
        return;
    }

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    // try a fast search for surfels that have been allocated any older frame
    // because the shader that spawns surfels from the gbuffer has yet to be executed
    uint surfel_id = bvh_search(origin);
    if ((surfel_id == SURFELS_MISSED) || (surfel_id == SURFELS_TOO_CLOSE)) {
        // there is no surfel associated with this pixel
        return;
    }

    imageStore(surfelOverlappingImage, texel_position, uvec4(surfel_id, 0, 0, 0));
/*
    for (uint i = 0; i < MAX_USABLE_SURFELS; i++) {
        // we can proceed at attempting to add the surfel to the list of used surfels
        const uint old_value = atomicCompSwap(discovered[i], USED_SURFEL_MISSING, surfel_id);
        if (old_value == surfel_id) {
            // my surfel was already discovered in another thread
            return;
        } else if (old_value == USED_SURFEL_MISSING) {
            // I successfully added my surfel to the list of discovered surfels
            
            // update the last time the surfel was used
            surfels[surfel_id].latest_contribution = 0;
            memoryBarrierBuffer();

            return;
        }
    }

    debugPrintfEXT("Reached maximum number of usable surfels on id(%u, %u)\n", gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
*/


    /*
    // ================================
    // Low level debug visualization of (old) surfels
    const uint available_surfels = count_ordered_surfels();
    if (available_surfels == 0) {
        contribution = vec3(2500.0, 2500.0, 2500.0);
    }

    uint surfel_id = SURFELS_MISSED;
    uint last_morton = 0;
    for (uint i = 0; i < available_surfels; i++) {
        if (last_morton > surfels[i].morton) {
            // this should never happen
            //debugPrintfEXT("MORTON SORT ERROR AT SURFEL %u %u > %u\n", i, last_morton, surfels[i].morton);
            //contribution = vec3(2500.0, 2500.0, 2500.0);
        }

        last_morton = surfels[i].morton;

        if (is_point_in_surfel(i, origin)) {
            surfel_id = i;
            break;
        }
    }
    // ================================
    */

    /*
    // this function only searches for surfels that were allocated before this frame
    const uint surfel_id = linear_search_ordered_surfel_for_allocation(
        eye_position,
        clip_planes,
        origin,
        instance_id,
        // we don't want to query for surfels too close: this check is useless
        0.0001
    );

    if (surfel_id != SURFELS_MISSED) {
        if (surfels[surfel_id].contributions > 200u) {
            contribution = vec3(0.0, 250.0, 0.0);
        } else {
            if (surfel_is_primary(surfel_id)) {
                contribution = vec3(0.0, 0.0, 250.0);
            } else {
                contribution = vec3(250.0, 0.0, 0.0);
            }
        }
    }
    */
}
