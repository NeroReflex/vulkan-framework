//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define SURFELS_DESCRIPTOR_SET 5
#include "../surfel.glsl"

#define RT_DESCRIPTOR_SET 0
#include "../rt_descriptor_set.glsl"

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

#define STATUS_DESCRIPTOR_SET 2
#include "../status.glsl"

layout(location = 0) rayPayloadEXT hit_payload_t payload;

// WARNING: this MUST be a power of two!
#define FIRST_PASS_RAYS 8

vec3 random_point_on_unit_sphere(inout uint state)
{
  float z = rnd(state) * 2.0 - 1.0;
  float t = rnd(state) * 6.28318530718; // 2 * PI
  float r = sqrt(1.0 - z * z);
  return vec3(r * cos(t), r * sin(t), z);
}

vec3 contribution(in vec3 surface_color, in float light_intensity, in float diffuse_coefficient)
{
    return surface_color * light_intensity * diffuse_coefficient;
}

// this function returns uvec2(split_element, elements_after)
uvec2 find_split_range(in const vec3 eye_position, in const vec2 clip_space, const uint start, const uint size, vec3 point) {
    const uint key = morton3D(eye_position, point, clip_space);

    const uint index = binary_search_bound(start, size, key, false);

    return uvec2(index, count_ordered_surfels() - index);
}

#define BIAS_PARAM 0.5

uint importance_sample_surfel(
    in const vec3 eye_position,
    in const vec2 clip_space,
    vec3 point,
    inout uint prev,
    inout float sample_prob    
) {
    const uvec2 split = find_split_range(eye_position, clip_space, 0, count_ordered_surfels(), point);

    bool higher = false;
    if (lcg(prev) % 2u == 0u) {
        higher = true;
    }

    const uint count = higher ? split.y : split.x;
    const float random_offset = biasedRandom(prev, count, BIAS_PARAM);
    const float prob = relativeProbability(random_offset, count, BIAS_PARAM);

    uint index = /* abs( */ uint(floor(random_offset)) /* ) */;
    index += higher ? split.x : 0u;

    sample_prob = prob;

    return index;
}

uint importance_sample_surfel_beyond_horizon(
    in const vec3 eye_position,
    in const vec2 clip_space,
    vec3 point,
    inout uint prev,
    inout float sample_prob    
) {
    uint surfel_index = 0xFFFFFFFFu;
    uint retry = 0;
    do {
        uint surfel_index = importance_sample_surfel(
            eye_position,
            clip_space,
            point,
            prev,
            sample_prob
        );

        const vec3 surfel_center = vec3(surfels[surfel_index].position_x, surfels[surfel_index].position_y, surfels[surfel_index].position_z);
        const vec3 surfel_normal = vec3(surfels[surfel_index].normal_x, surfels[surfel_index].normal_y, surfels[surfel_index].normal_z);
        if (is_below_horizon(surfel_normal, surfel_center - point)) {
            surfel_index = 0xFFFFFFFFu;
            continue;
        }

        return surfel_index;
    } while ((surfel_index == 0xFFFFFFFFu) && (retry < 8));
}

vec3 sample_contributions(
    in const vec3 eye_position,
    in const vec2 clip_space,
    vec3 point,
    vec3 normal,
    inout uint prev
) {
    vec3 contribution_sum = vec3(0.0, 0.0, 0.0);
    float total_weight = 0.0;
    uint samples = 0;
    for (uint i = 0; i < SURFEL_IMPORTANCE_SAMPLES; i++) {
        float sample_prob = 1.0;
        const uint surfel_index = importance_sample_surfel_beyond_horizon(
            eye_position,
            clip_space,
            point,
            prev,
            sample_prob
        );

        if (surfel_index == 0xFFFFFFFFu) {
            continue;
        }

        const vec3 surfel_center = vec3(surfels[surfel_index].position_x, surfels[surfel_index].position_y, surfels[surfel_index].position_z);
        const vec3 surfel_normal = vec3(surfels[surfel_index].normal_x, surfels[surfel_index].normal_y, surfels[surfel_index].normal_z);

        const float surfel_radius = surfels[surfel_index].radius;
        const float surfel_contributions = float(surfels[surfel_index].contributions);

        const float dist = distance(surfel_center, point);
        if (dist < CLOSEST_INTERSECTION_DISTANCE) {
            continue;
        }

        if (!lock_surfel(surfel_index)) {
            // this surfel is being modified: skip it
            continue;
        }

        const vec3 ray_dir = normalize(surfel_center - point);
        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            point.xyz,
            CLOSEST_INTERSECTION_DISTANCE,
            ray_dir.xyz,
            10000.0,
            0
        );

        // uhm.... what? This should be possible, but let's ignore it and print a message.
        if (!payload.hit) {
            debugPrintfEXT("I haven't hit the surfel %u. Weird.\n", surfel_index);

            unlock_surfel(surfel_index);
            continue;
        }

        /*
        // this isn't implemented yet as instance_id is not correctly propagated
        if (payload.instance_id != surfels[surfel_index].instance_id) {
            // the ray hit something else before reaching the surfel
            continue;
        }
        */

        // test the depth instead
        const float hit_distance = distance(payload.position, point);
        if ((hit_distance < dist - 1.0) || (hit_distance > dist + 1.0)) {
            // the ray hit something else before reaching the surfel
            unlock_surfel(surfel_index);
            continue;
        }

        const vec3 surfel_diffuse = vec3(surfels[surfel_index].irradiance_r, surfels[surfel_index].irradiance_g, surfels[surfel_index].irradiance_b) / float(surfels[surfel_index].contributions);
        contribution_sum += surfel_diffuse * max(dot(normal, ray_dir), 0.0) * sample_prob;

        samples += 1;
    }

    return contribution_sum / float(samples);
}

#define MAX_RAY_DEPTH 2

#define DEPTH_IGNORE 1.0

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    // we have already accumulated enough frames: do nothing
    if (gi_data.gi_reuse_frames >= 0xFFFFFFFEu) {
        return;
    }

    const vec3 old_gi_data = gi_data.gi_reuse_frames > 0 ? imageLoad(outputImage[0], ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;
    const vec3 specular = texelFetch(gbuffer[3], texel_position, 0).xyz;
    const float depth = texture(gbuffer_depth, vec3(float(texel_position.x) / float(resolution.x), float(texel_position.y) / float(resolution.y), 1.0));

    const uvec4 instance_data = texelFetch(gbuffer_instance_id, texel_position, 0);
    const uint mesh_id = instance_data.x;
    const uint instance_id = instance_data.y;

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();
    const vec3 view_dir = normalize(eye_position - origin);

    /*
    // debug print of discovered surfels
    if (texel_position == ivec2(0, 0)) {
        debugPrintfEXT("Number of discovered surfels: %u\n", count_discoveder_surfels());
    }
    */

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    // direct lighting: only compute it if the previous GI data cannot be reused
    if ((gi_data.gi_reuse_frames == 0) && (depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        vec3 lights_contribution = vec3(0.0, 0.0, 0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) > 0.1) {
                if (!(origin.x == 0 && origin.y == 0 && origin.z == 0)) {
                    // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                        0xff,
                        0,
                        0,
                        0,
                        origin.xyz,
                        CLOSEST_INTERSECTION_DISTANCE,
                        ray_dir.xyz,
                        10000.0,
                        0
                    );
                }

                if (!payload.hit) {
                    diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                    const vec3 diffuse_component = diffuse_contribution * light_intensity * diffuse;

                    const vec3 reflect_dir = reflect(-light_dir, normal);
                    specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                    const vec3 specular = specular_contribution * light_intensity * specular;

                    // TODO: here sum specular
                    lights_contribution += diffuse_component;

                    register_surfel(
                        eye_position,
                        clip_planes,
                        payload.instance_id,
                        origin,
                        normal,
                        diffuse_contribution * light_intensity
                    );
                }
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }

    hit_payload_t collisions[MAX_RAY_DEPTH];
    vec3 ray_directions[MAX_RAY_DEPTH];

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    uint contribution_samples = 0;

#if SHOW_SURFELS
    if ((depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        
        /*
        // ================================
        // Low level debug visualization of (old) surfels
        const uint available_surfels = count_ordered_surfels();
        if (available_surfels == 0) {
            contribution = vec3(2500.0, 2500.0, 2500.0);
        }

        uint surfel_id = SURFELS_MISSED;
        uint last_morton = 0;
        for (uint i = 0; i < available_surfels; i++) {
            if (last_morton > surfels[i].morton) {
                // this should never happen
                //debugPrintfEXT("MORTON SORT ERROR AT SURFEL %u %u > %u\n", i, last_morton, surfels[i].morton);
                //contribution = vec3(2500.0, 2500.0, 2500.0);
            }

            last_morton = surfels[i].morton;

            if (is_point_in_surfel(i, origin)) {
                surfel_id = i;
                break;
            }
        }
        // ================================
        */

        // this function only searches for surfels that were allocated before this frame
        const uint surfel_id = linear_search_ordered_surfel_for_allocation(
            eye_position,
            clip_planes,
            origin,
            instance_id,
            // we don't want to query for surfels too close: this check is useless
            0.0001
        );

        if (surfel_id != SURFELS_MISSED) {
            if (surfels[surfel_id].contributions > 200u) {
                contribution = vec3(0.0, 250.0, 0.0);
            } else {
                if (surfel_is_primary(surfel_id)) {
                    contribution = vec3(0.0, 0.0, 250.0);
                } else {
                    contribution = vec3(250.0, 0.0, 0.0);
                }
            }

            contribution *= vec3(surfels[surfel_id].contributions) * 1.0;
        }
    }
#endif

    uint casted_primary_rays = 0;
    uint ray_depth = 0;
    if ((depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        while ((ray_depth < MAX_RAY_DEPTH) /*&& (!SHOW_SURFELS)*/) {
            // cast a ray in a random direction over the hemisphere oriented by the normal
            // accumulate the contribution of the ray if it hits something
            // if it hits nothing, stop
            // if it hits something, repeat
            if (casted_primary_rays == FIRST_PASS_RAYS) {
                break;
            }

            const vec3 random_point_on_sphere = random_point_on_unit_sphere(seed);
            vec3 ray_dir = reflect(normal, random_point_on_sphere);
            ray_dir = is_below_horizon(normal, random_point_on_sphere) ? -ray_dir : ray_dir;

            ray_directions[ray_depth] = ray_dir;
            if (ray_depth == 0) {
                casted_primary_rays += 1;
            }

            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                ray_depth == 0 ? origin.xyz : collisions[ray_depth - 1].position.xyz,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_directions[ray_depth].xyz,
                10000.0,
                0
            );

            collisions[ray_depth] = payload;

            if (collisions[ray_depth].hit) {
                // from the new point try to query all the directional lights
                for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                    const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                    const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                    if (length(directional_light_dir) <= 0.1) {
                        continue;
                    }

                    //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                    //    continue;
                    //}

                    // check for this directional light
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsNoneEXT,
                        0xff,
                        0,
                        0,
                        0,
                        collisions[ray_depth].position,
                        CLOSEST_INTERSECTION_DISTANCE,
                        directional_light_dir,
                        10000.0,
                        0
                    );

                    // shadow ray is not occluded: sum the contribution of this point
                    if (!payload.hit) {
                        // when calculating directional light contribution, account for the entire path
                        // the light has been reflected at each bounce according to the diffuse coefficient
                        // (so the contribution is attenuated at each bounce)
                        // also account for the angle of incidence of the light on each surface (Lambertian
                        // reflectance):
                        //
                        // To do this associate the diffuse texture and normal of the last SURELY hit surface collisions[ray_depth-1]
                        // (or "diffuse" and "normal" in case ray_depth is 0), and the ray_direction at that point collisions[ray_depth]
                        // (or directional_light_dir if ray_depth is )

                        vec3 incoming_diffuse_light = directional_light_intensity;
                        uint r = ray_depth;
                        while (1 == 1) {
                            vec3 surface_normal = r == 0 ? normal : collisions[r].triangle_normal;
                            vec3 surface_diffuse = r == 0 ? diffuse : collisions[r].diffuse;
                            vec3 surface_ray = r == ray_depth ? directional_light_dir : ray_directions[r + 1];

                            incoming_diffuse_light *= max(dot(surface_normal, surface_ray), 0.0) * surface_diffuse;

                            if (r == 0) {
                                break;
                            } else {
                                r -= 1;
                            }
                        }

                        if (
                            incoming_diffuse_light.x > RADIANCE_THRESHOLD ||
                            incoming_diffuse_light.y > RADIANCE_THRESHOLD ||
                            incoming_diffuse_light.z > RADIANCE_THRESHOLD
                        ) {
                            register_surfel(
                                eye_position,
                                clip_planes,
                                payload.instance_id,
                                collisions[ray_depth].position,
                                collisions[ray_depth].triangle_normal,
                                incoming_diffuse_light
                            );
                        }

                        contribution += incoming_diffuse_light;
                        if (ray_depth == 0) {
                            contribution_samples += 1;
                        }
                        //contribution += vec3(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0);
                    }
                }
            }

            // no surface hit: restart from the beginning
            if (collisions[ray_depth].hit) {
                ray_depth++;
            } else {
                ray_depth = 0;
            }
        }
    }

    //const vec3 surfels_contribution = sample_contributions(
    //    eye_position,
    //    clip_planes,
    //    origin,
    //    normal,
    //    seed
    //);


    // use visible surfels to contribute to the GI
    vec3 surfels_contributions = vec3(0.0, 0.0, 0.0);
    uint surfels_contributions_count = 0;
    /*
    const uint discovered_surfels_count = count_discoveder_surfels();
    if (discovered_surfels_count == 0) {
        // no surfels discovered: store the old data and exit
        imageStore(outputImage[0], texel_position, vec4(old_gi_data / 2.0, 1.0));
        return;
    }
    */

    /*
    uint surface_samples = min(VIRTUAL_POINT_LIGHTS_PER_PIXEL, count_ordered_surfels());
    for (uint i = 0; i < surface_samples; i++) {
        const uint discovered_index = lcg(seed) % count_ordered_surfels();

        if (discovered[discovered_index] == USED_SURFEL_MISSING) {
            break;
        }

        // assume a hit if the distance is too short
        bool hit = false;
        const vec3 surfel_pos = surfelPosition(surfels[discovered[discovered_index]]);
        const float origin_surfel_distance = distance(surfel_pos, origin);
        if (origin_surfel_distance > 2.0 * CLOSEST_INTERSECTION_DISTANCE) {
            const vec3 ray_dir = normalize(surfel_pos - origin);
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                surfel_pos.xyz,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_dir.xyz,
                origin_surfel_distance - CLOSEST_INTERSECTION_DISTANCE,
                0
            );

            hit = payload.hit;
        }

        if (!hit) {
            // the surfel is visible: add its contribution
            surfels_contributions += projected_irradiance(surfels[discovered[discovered_index]], origin, normal);
        }
        
        surfels_contributions_count += 1;
    }
    */

    // this is the monte-carlo estimate of the GI at this point
    //const vec3 mc_gi_contribution = (old_gi_data + (contribution / float(FIRST_PASS_RAYS))) / float(gi_data.gi_reuse_frames + 1u);
    const vec3 mc_gi_contribution = (old_gi_data * float(gi_data.gi_reuse_frames) + (contribution / float(FIRST_PASS_RAYS))) / float(gi_data.gi_reuse_frames + 1u);

    // if there is enough light incoming on this this point make a surfel out of it!
    if (
        mc_gi_contribution.x > RADIANCE_THRESHOLD ||
        mc_gi_contribution.y > RADIANCE_THRESHOLD ||
        mc_gi_contribution.z > RADIANCE_THRESHOLD
    ) {
        register_surfel(
            eye_position,
            clip_planes,
            instance_id,
            origin,
            normal,
            mc_gi_contribution
        );
    }

    imageStore(outputImage[0], texel_position, vec4(mc_gi_contribution, 1.0));
}
