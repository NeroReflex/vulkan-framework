//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "payload.glsl"
#include "random.glsl"

// keep this in sync with the rust side
#define MAX_DIRECTIONAL_LIGHTS 8

layout (set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

// gbuffer: 0 for position, 1 for normal, 2 for diffuse texture
layout (set = 1, binding = 0) uniform sampler2D gbuffer[3];

struct light_t {
    float direction_x;
    float direction_y;
    float direction_z;

    float intensity_x;
    float intensity_y;
    float intensity_z;
};

layout(std140, set = 2, binding = 0) uniform camera_uniform {
	mat4 viewMatrix;
	mat4 projectionMatrix;
} camera;

layout(std430, set = 2, binding = 1) readonly buffer directional_lights
{
    light_t light[];
};

uniform layout (set = 5, binding = 0, rgba32f) image2D outputImage[2];

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define FIRST_PASS_RAYS 2

layout(push_constant) uniform GIData {
    uint gi_reuse_frames;
} gi_data;

vec3 random_point_on_unit_sphere(inout uint state)
{
  float z = rnd(state) * 2.0 - 1.0;
  float t = rnd(state) * 6.28318530718; // 2 * PI
  float r = sqrt(1.0 - z * z);
  return vec3(r * cos(t), r * sin(t), z);
}

vec3 contribution(in vec3 surface_color, in float light_intensity, in float diffuse_coefficient)
{
    return surface_color * light_intensity * diffuse_coefficient;

}

#define MAX_RAY_DEPTH 3

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    const vec3 old_gi_data = gi_data.gi_reuse_frames > 0 ? imageLoad(outputImage[0], ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;

    const vec3 eye_position = vec3(camera.viewMatrix[3][0], camera.viewMatrix[3][1], camera.viewMatrix[3][2]);
    const vec3 view_dir = normalize(eye_position - origin);

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    // direct lighting: only compute it if the previous GI data cannot be reused
    if (gi_data.gi_reuse_frames == 0) {
        vec3 lights_contribution = vec3(0.0, 0.0, 0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) > 0.1) {
                if (!(origin.x == 0 && origin.y == 0 && origin.z == 0)) {
                    // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                        0xff,
                        0,
                        0,
                        0,
                        origin.xyz,
                        1.0,
                        ray_dir.xyz,
                        10000.0,
                        0
                    );
                }

                if (!payload.hit) {
                    diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                    const vec3 diffuse = diffuse_contribution * light_intensity * diffuse;

                    const vec3 reflect_dir = reflect(-light_dir, normal);
                    specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                    // TODO: here change diffuse texture with specular texture
                    const vec3 specular = specular_contribution * light_intensity * diffuse;

                    // TODO: here sum specular
                    lights_contribution += diffuse;
                }
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }


    hit_payload_t collisions[MAX_RAY_DEPTH];
    vec3 ray_directions[MAX_RAY_DEPTH];

    vec3 contribution = vec3(0.0, 0.0, 0.0);

    uint casted_primary_rays = 0;
    uint ray_depth = 0;
    while (ray_depth < MAX_RAY_DEPTH) {
        // cast a ray in a random direction over the hemisphere oriented by the normal
        // accumulate the contribution of the ray if it hits something
        // if it hits nothing, stop
        // if it hits something, repeat
        if (casted_primary_rays == FIRST_PASS_RAYS) {
            break;
        }

        const vec3 random_point_on_sphere = random_point_on_unit_sphere(seed);
        vec3 ray_dir = reflect(normal, random_point_on_sphere);
        const bool below_horizon = dot(normal, random_point_on_sphere) < 0;
        ray_dir = below_horizon ? -ray_dir : ray_dir;

        ray_directions[ray_depth] = ray_dir;
        if (ray_depth == 0) {
            casted_primary_rays += 1;
        }

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            ray_depth == 0 ? origin.xyz : collisions[ray_depth - 1].position.xyz,
            0.1,
            ray_directions[ray_depth].xyz,
            10000.0,
            0
        );

        collisions[ray_depth] = payload;

        // exclude the first ray since it was done in the directional lighting pass already
        if (ray_depth > 0) {
            // from the new point try to query all the directional lights
            for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                if (length(directional_light_dir) <= 0.1) {
                    continue;
                }

                //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                //    continue;
                //}

                // check for this directional light
                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsNoneEXT,
                    0xff,
                    0,
                    0,
                    0,
                    collisions[ray_depth-1].position,
                    0.1,
                    directional_light_dir,
                    10000.0,
                    0
                );

                // shadow ray is not occluded: sum the contribution of this point
                if (!payload.hit) {
                    // when calculating directional light contribution, account for the entire path
                    // the light has been reflected at each bounce according to the diffuse coefficient
                    // (so the contribution is attenuated at each bounce)
                    // also account for the angle of incidence of the light on each surface (Lambertian
                    // reflectance):
                    //
                    // To do this associate the diffuse texture and normal of the last SURELY hit surface collisions[ray_depth-1]
                    // (or "diffuse" and "normal" in case ray_depth is 0), and the ray_direction at that point collisions[ray_depth]
                    // (or directional_light_dir if ray_depth is )

                    vec3 incoming_diffuse_light = vec3(1.0, 1.0, 1.0);
                    for (uint r = ray_depth; r > 0; r--) {
                        vec3 surface_normal = r == 0 ? normal : collisions[r - 1].triangle_normal;
                        vec3 surface_diffuse = r == 0 ? diffuse : collisions[r - 1].diffuse;
                        vec3 surface_ray = r == ray_depth ? directional_light_dir : ray_directions[r];

                        incoming_diffuse_light *= max(dot(surface_normal, surface_ray), 0.0) * surface_diffuse;
                    }

                    contribution += incoming_diffuse_light;
                    //contribution += vec3(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0);
                }

            }
        }

        // no surface hit: restart from the beginning
        if (collisions[ray_depth].hit) {
            ray_depth++;
        } else {
            ray_depth = 0;
        }
    }

    const float reused_scale = gi_data.gi_reuse_frames > 0 ? 2.0 : 1.0;
    imageStore(outputImage[0], texel_position, vec4((old_gi_data / 2.0) + (contribution / (float(FIRST_PASS_RAYS) * reused_scale)), 1.0));
    //imageStore(outputImage, texel_position, vec4(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0, 1.0));
}
