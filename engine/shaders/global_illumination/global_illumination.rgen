//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "payload.glsl"
#include "../sphere_points.glsl"

// keep this in sync with the rust side
#define MAX_DIRECTIONAL_LIGHTS 8

// just a stub
layout (set = 0, binding = 0, std430) readonly buffer tlas_instances
{
    uint data[];
};

layout (set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

// gbuffer: 0 for position, 1 for normal, 2 for diffuse texture
layout (set = 1, binding = 0) uniform sampler2D gbuffer[3];

struct light_t {
    float direction_x;
    float direction_y;
    float direction_z;

    float intensity_x;
    float intensity_y;
    float intensity_z;
};

layout(set = 2, binding = 1) uniform sampler2D dlbuffer[MAX_DIRECTIONAL_LIGHTS];
layout(std430, set = 2, binding = 0) readonly buffer directional_lights
{
    light_t light[];
};

uniform layout (set = 5, binding = 0, rgba32f) image2D outputImage;

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define FIRST_PASS_RAYS 12

void main() {
    const ivec2 resolution = imageSize(outputImage);

    const vec2 position_xy = vec2(float(gl_LaunchIDEXT.x) / float(resolution.x), float(gl_LaunchIDEXT.y) / float(resolution.y));

    const vec3 origin = texture(gbuffer[0], position_xy).xyz;
    const vec3 normal = texture(gbuffer[1], position_xy).xyz;

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    for (uint ray_index_1 = 0; ray_index_1 < FIRST_PASS_RAYS; ray_index_1++) {
        const vec3 random_point_on_sphere = random_point_first[ray_index_1];
        vec3 ray_dir = reflect(normal, random_point_on_sphere);
        const bool below_horizon = dot(normal, random_point_on_sphere) < 0;
        ray_dir = below_horizon ? -ray_dir : ray_dir;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            origin.xyz,
            0.1,
            ray_dir.xyz,
            10000.0,
            0
        );

        const hit_payload_t first_surface = payload;
        if (!first_surface.hit) {
            continue;
        }

        // test for collisions (REMOVE ME)
            {
                contribution += vec3(100.0, 100.0, 100.0);
                continue;
            }

        for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
            const vec3 directional_light_dir = -1.0 * vec3(light[dir_light_index].direction_x, light[dir_light_index].direction_y, light[dir_light_index].direction_z);
            const vec3 directional_light_intensity = vec3(light[dir_light_index].intensity_x, light[dir_light_index].intensity_y, light[dir_light_index].intensity_z);
            if (length(directional_light_dir) <= 0.1) {
                continue;
            }

            //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
            //    continue;
            //}

            

            // check for this directional light
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                first_surface.position.xyz,
                0.1,
                directional_light_dir.xyz,
                10000.0,
                0
            );

            const hit_payload_t second_surface = payload;


            if (second_surface.hit) {
                continue;
            }

            

            // shadow ray is not occluded: sum the contribution of this point
            const float coeff_directional_light = max(dot(first_surface.triangle_normal, directional_light_dir.xyz), 0.0);
            const vec3 directional_light_effective_intensity = coeff_directional_light * directional_light_intensity;
            const vec3 diffuse_contibution = directional_light_effective_intensity * first_surface.diffuse;
            contribution += diffuse_contibution;
        }

        const float first_hit_coefficient = max(dot(first_surface.triangle_normal, ray_dir), 0.0);
        // from here one 
    }

    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(contribution / float(SPHERE_POINTS_FIRST), 1.0));
}
