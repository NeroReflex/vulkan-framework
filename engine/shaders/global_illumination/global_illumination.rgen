//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define SURFELS_DESCRIPTOR_SET 5
#include "../surfel.glsl"

#define RT_DESCRIPTOR_SET 0
#include "../rt_descriptor_set.glsl"

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

#define STATUS_DESCRIPTOR_SET 2
#include "../status.glsl"

layout(location = 0) rayPayloadEXT hit_payload_t payload;

// WARNING: this MUST be a power of two!
#define FIRST_PASS_RAYS 8

vec3 contribution(in vec3 surface_color, in float light_intensity, in float diffuse_coefficient)
{
    return surface_color * light_intensity * diffuse_coefficient;
}

// this function returns uvec2(split_element, elements_after)
uvec2 find_split_range(in const vec3 eye_position, in const vec2 clip_space, const uint start, const uint size, vec3 point) {
    const uint key = morton3D(eye_position, point, clip_space);

    const uint index = binary_search_bound(start, size, key, false);

    return uvec2(index, count_ordered_surfels() - index);
}

#define BIAS_PARAM 0.5

#define MAX_RAY_DEPTH 2

#define DEPTH_IGNORE 1.0

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    // we have already accumulated enough frames: do nothing
    if (gi_data.gi_reuse_frames >= 0xFFFFFFFEu) {
        return;
    }

    const vec3 old_gi_data = gi_data.gi_reuse_frames > 0 ? imageLoad(outputImage[0], ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;
    const vec3 specular = texelFetch(gbuffer[3], texel_position, 0).xyz;
    const float depth = texture(gbuffer_depth, vec3(float(texel_position.x) / float(resolution.x), float(texel_position.y) / float(resolution.y), 1.0));

    const uvec4 instance_data = texelFetch(gbuffer_instance_id, texel_position, 0);
    const uint mesh_id = instance_data.x;
    const uint instance_id = instance_data.y;

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();
    const vec3 view_dir = normalize(eye_position - origin);

    // debug print of discovered surfels
    //if (texel_position == ivec2(0, 0)) {
    //    debugPrintfEXT("clip planes: %f %f\n", clip_planes.x, clip_planes.y);
    //    debugPrintfEXT("Number of discovered surfels: %u\n", count_discoveder_surfels());
    //}

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    // direct lighting: only compute it if the previous GI data cannot be reused
    uint surfel_id = REGISTER_SURFEL_IGNORED;
    bool fresh_allocation = false;
    if ((gi_data.gi_reuse_frames == 0) && (depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        vec3 lights_contribution = vec3(0.0, 0.0, 0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) > 0.1) {
                if (!(origin.x == 0 && origin.y == 0 && origin.z == 0)) {
                    // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                        0xff,
                        0,
                        0,
                        0,
                        origin.xyz,
                        CLOSEST_INTERSECTION_DISTANCE,
                        ray_dir.xyz,
                        10000.0,
                        0
                    );
                }

                if (!payload.hit) {
                    diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                    const vec3 diffuse_component = diffuse_contribution * light_intensity * diffuse;

                    const vec3 reflect_dir = reflect(-light_dir, normal);
                    specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                    const vec3 specular = specular_contribution * light_intensity * specular;

                    // TODO: here sum specular
                    lights_contribution += diffuse_component;

                    if (!IS_SURFEL_VALID(surfel_id)) {
                        surfel_id = find_surfel_or_allocate_new(
                            eye_position,
                            clip_planes,
                            instance_id,
                            origin,
                            normal,
                            diffuse,
                            fresh_allocation
                        );

                        if (fresh_allocation) {
                            debugPrintfEXT("DL spawn surfel %u at pixel %u,%u\n", surfel_id, texel_position.x, texel_position.y);
                        }
                    }

                    // as a rule globally valid it is the surfel spawner's responsibility
                    // to calculate directional light contribution to the surfel
                    // becuase it is something that can be analytically calculated.
                    if (IS_SURFEL_VALID(surfel_id) && fresh_allocation) {
                        bool locked = false;
                        do {
                            locked = lock_surfel(surfel_id);
                        } while (!locked);

                        // TODO: register this incoming light to the surfel

                        unlock_surfel(surfel_id);
                        memoryBarrierBuffer();
                    }
                }
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }

    hit_payload_t collisions[MAX_RAY_DEPTH];
    vec3 ray_directions[MAX_RAY_DEPTH];

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    uint contribution_samples = 0;

#if SHOW_SURFELS
    if ((depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        
        /*
        // ================================
        // Low level debug visualization of (old) surfels
        const uint available_surfels = count_ordered_surfels();
        if (available_surfels == 0) {
            contribution = vec3(2500.0, 2500.0, 2500.0);
        }

        uint surfel_id = SURFELS_MISSED;
        uint last_morton = 0;
        for (uint i = 0; i < available_surfels; i++) {
            if (last_morton > surfels[i].morton) {
                // this should never happen
                //debugPrintfEXT("MORTON SORT ERROR AT SURFEL %u %u > %u\n", i, last_morton, surfels[i].morton);
                //contribution = vec3(2500.0, 2500.0, 2500.0);
            }

            last_morton = surfels[i].morton;

            if (is_point_in_surfel(i, origin)) {
                surfel_id = i;
                break;
            }
        }
        // ================================
        */

        // this function only searches for surfels that were allocated before this frame
        const uint surfel_id = linear_search_ordered_surfel_for_allocation(
            eye_position,
            clip_planes,
            origin,
            instance_id,
            // we don't want to query for surfels too close: this check is useless
            0.0001
        );

        if (surfel_id != SURFELS_MISSED) {
            if (surfels[surfel_id].contributions > 200u) {
                contribution = vec3(0.0, 250.0, 0.0);
            } else {
                if (surfel_is_primary(surfel_id)) {
                    contribution = vec3(0.0, 0.0, 250.0);
                } else {
                    contribution = vec3(250.0, 0.0, 0.0);
                }
            }

            contribution *= vec3(surfels[surfel_id].contributions) * 1.0;
        }
    }
#endif

    uint casted_primary_rays = 0;
    uint ray_depth = 0;
    if ((depth < DEPTH_IGNORE) && (mesh_id != 0xFFFFFFFFu)) {
        while ((ray_depth < MAX_RAY_DEPTH) /*&& (!SHOW_SURFELS)*/) {
            // cast a ray in a random direction over the hemisphere oriented by the normal
            // accumulate the contribution of the ray if it hits something
            // if it hits nothing, stop
            // if it hits something, repeat
            if (casted_primary_rays == FIRST_PASS_RAYS) {
                break;
            }

            const vec3 random_point_on_sphere = random_point_on_unit_sphere(seed);
            vec3 ray_dir = reflect(normal, random_point_on_sphere);
            ray_dir = is_below_horizon(normal, random_point_on_sphere) ? -ray_dir : ray_dir;

            ray_directions[ray_depth] = ray_dir;
            if (ray_depth == 0) {
                casted_primary_rays += 1;
            }

            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                ray_depth == 0 ? origin.xyz : collisions[ray_depth - 1].position.xyz,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_directions[ray_depth].xyz,
                10000.0,
                0
            );

            collisions[ray_depth] = payload;

            if (collisions[ray_depth].hit) {
                // from the new point try to query all the directional lights
                for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                    const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                    const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                    if (length(directional_light_dir) <= 0.1) {
                        continue;
                    }

                    //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                    //    continue;
                    //}

                    // check for this directional light
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsNoneEXT,
                        0xff,
                        0,
                        0,
                        0,
                        collisions[ray_depth].position,
                        CLOSEST_INTERSECTION_DISTANCE,
                        directional_light_dir,
                        10000.0,
                        0
                    );

                    // shadow ray is not occluded: sum the contribution of this point
                    if (!payload.hit) {
                        // when calculating directional light contribution, account for the entire path
                        // the light has been reflected at each bounce according to the diffuse coefficient
                        // (so the contribution is attenuated at each bounce)
                        // also account for the angle of incidence of the light on each surface (Lambertian
                        // reflectance):
                        //
                        // To do this associate the diffuse texture and normal of the last SURELY hit surface collisions[ray_depth-1]
                        // (or "diffuse" and "normal" in case ray_depth is 0), and the ray_direction at that point collisions[ray_depth]
                        // (or directional_light_dir if ray_depth is )

                        vec3 incoming_diffuse_light = directional_light_intensity;
                        uint r = ray_depth;
                        while (1 == 1) {
                            vec3 surface_normal = r == 0 ? normal : collisions[r].triangle_normal;
                            vec3 surface_diffuse = r == 0 ? diffuse : collisions[r].diffuse;
                            vec3 surface_ray = r == ray_depth ? directional_light_dir : ray_directions[r + 1];

                            incoming_diffuse_light *= max(dot(surface_normal, surface_ray), 0.0) * surface_diffuse;

                            if (r == 0) {
                                break;
                            } else {
                                r -= 1;
                            }
                        }

                        if (
                            incoming_diffuse_light.x > RADIANCE_THRESHOLD ||
                            incoming_diffuse_light.y > RADIANCE_THRESHOLD ||
                            incoming_diffuse_light.z > RADIANCE_THRESHOLD
                        ) {
                            find_surfel_or_allocate_new(
                                eye_position,
                                clip_planes,
                                collisions[ray_depth].instance_id,
                                collisions[ray_depth].position,
                                collisions[ray_depth].triangle_normal,
                                collisions[ray_depth].diffuse,
                                fresh_allocation
                            );
                        }

                        contribution += incoming_diffuse_light;
                        if (ray_depth == 0) {
                            contribution_samples += 1;
                        }
                        //contribution += vec3(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0);
                    }
                }
            }

            // no surface hit: restart from the beginning
            if (collisions[ray_depth].hit) {
                ray_depth++;
            } else {
                ray_depth = 0;
            }
        }
    }

    //const vec3 surfels_contribution = sample_contributions(
    //    eye_position,
    //    clip_planes,
    //    origin,
    //    normal,
    //    seed
    //);


    // use visible surfels to contribute to the GI
    vec3 surfels_contributions = vec3(0.0, 0.0, 0.0);
    uint surfels_contributions_count = 0;
    /*
    const uint discovered_surfels_count = count_discoveder_surfels();
    if (discovered_surfels_count == 0) {
        // no surfels discovered: store the old data and exit
        imageStore(outputImage[0], texel_position, vec4(old_gi_data / 2.0, 1.0));
        return;
    }
    */

    /*
    uint surface_samples = min(VIRTUAL_POINT_LIGHTS_PER_PIXEL, count_ordered_surfels());
    for (uint i = 0; i < surface_samples; i++) {
        const uint discovered_index = lcg(seed) % count_ordered_surfels();

        if (discovered[discovered_index] == USED_SURFEL_MISSING) {
            break;
        }

        // assume a hit if the distance is too short
        bool hit = false;
        const vec3 surfel_pos = surfelPosition(surfels[discovered[discovered_index]]);
        const float origin_surfel_distance = distance(surfel_pos, origin);
        if (origin_surfel_distance > 2.0 * CLOSEST_INTERSECTION_DISTANCE) {
            const vec3 ray_dir = normalize(surfel_pos - origin);
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                surfel_pos.xyz,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_dir.xyz,
                origin_surfel_distance - CLOSEST_INTERSECTION_DISTANCE,
                0
            );

            hit = payload.hit;
        }

        if (!hit) {
            // the surfel is visible: add its contribution
            surfels_contributions += projected_irradiance(surfels[discovered[discovered_index]], origin, normal);
        }
        
        surfels_contributions_count += 1;
    }
    */

    // this is the monte-carlo estimate of the GI at this point
    //const vec3 mc_gi_contribution = (old_gi_data + (contribution / float(FIRST_PASS_RAYS))) / float(gi_data.gi_reuse_frames + 1u);
    const vec3 mc_gi_contribution = (old_gi_data * float(gi_data.gi_reuse_frames) + (contribution / float(FIRST_PASS_RAYS))) / float(gi_data.gi_reuse_frames + 1u);

    // if there is enough light incoming on this this point make a surfel out of it!
    if (
        mc_gi_contribution.x > RADIANCE_THRESHOLD ||
        mc_gi_contribution.y > RADIANCE_THRESHOLD ||
        mc_gi_contribution.z > RADIANCE_THRESHOLD
    ) {
        // if a surfel has not been already allocated for this pixel, try to allocate one now
        if (!IS_SURFEL_VALID(surfel_id)) {
            surfel_id = find_surfel_or_allocate_new(
                eye_position,
                clip_planes,
                instance_id,
                origin,
                normal,
                diffuse,
                fresh_allocation
            );

            if (fresh_allocation) {
                debugPrintfEXT("Visibility spawn surfel %u at pixel %u,%u\n", surfel_id, texel_position.x, texel_position.y);
            }
        }

        // if there is a surfel allocated for this pixel, try to lock it and update it
        if (IS_SURFEL_VALID(surfel_id)) {
            bool locked = false;
            if (fresh_allocation) {
                do {
                    locked = lock_surfel(surfel_id);
                } while (!locked);
            } else {
                locked = lock_surfel(surfel_id);
            }

            if (locked) {
                // TODO: register this incoming light to the surfel
                unlock_surfel(surfel_id);
                memoryBarrierBuffer();
            } else {
                //debugPrintfEXT("Failed to lock surfel %u to register GI update\n", surfel_id);
            }
        }
    }

    imageStore(outputImage[0], texel_position, vec4(mc_gi_contribution, 1.0));
}
