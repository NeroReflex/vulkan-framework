//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "payload.glsl"
#include "../sphere_points.glsl"

// keep this in sync with the rust side
#define MAX_DIRECTIONAL_LIGHTS 8

layout (set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

// gbuffer: 0 for position, 1 for normal, 2 for diffuse texture
layout (set = 1, binding = 0) uniform sampler2D gbuffer[3];

struct light_t {
    float direction_x;
    float direction_y;
    float direction_z;

    float intensity_x;
    float intensity_y;
    float intensity_z;
};

layout(std140, set = 2, binding = 0) uniform camera_uniform {
	mat4 viewMatrix;
	mat4 projectionMatrix;
} camera;

layout(std430, set = 2, binding = 1) readonly buffer directional_lights
{
    light_t light[];
};

uniform layout (set = 5, binding = 0, rgba32f) image2D outputImage[2];

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define FIRST_PASS_RAYS 12

layout(push_constant) uniform GIData {
    uint gi_reuse_frames;
} gi_data;

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    const vec3 old_gi_data = gi_data.gi_reuse_frames > 0 ? imageLoad(outputImage[0], ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;

    const vec3 eye_position = vec3(camera.viewMatrix[3][0], camera.viewMatrix[3][1], camera.viewMatrix[3][2]);
    const vec3 view_dir = normalize(eye_position - origin);

    // direct lighting: only compute it if the previous GI data cannot be reused
    if (gi_data.gi_reuse_frames == 0) {
        vec3 lights_contribution = vec3(0.0, 0.0, 0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) > 0.1) {
                if (!(origin.x == 0 && origin.y == 0 && origin.z == 0)) {
                    // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                        0xff,
                        0,
                        0,
                        0,
                        origin.xyz,
                        1.0,
                        ray_dir.xyz,
                        10000.0,
                        0
                    );
                }

                if (!payload.hit) {
                    diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                    const vec3 diffuse = diffuse_contribution * light_intensity * diffuse;

                    const vec3 reflect_dir = reflect(-light_dir, normal);
                    specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                    // TODO: here change diffuse texture with specular texture
                    const vec3 specular = specular_contribution * light_intensity * diffuse;

                    // TODO: here sum specular
                    lights_contribution += diffuse;
                }
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    for (uint ray_index_1 = 0; ray_index_1 < 1; ray_index_1++) {
        //const vec3 ray_dir = vec3(1.0, 0.0, 0.0);
        const vec3 random_point_on_sphere = vec3(-0.016828, 0.999740, -0.015416);
        vec3 ray_dir = reflect(normal, random_point_on_sphere);
        const bool below_horizon = dot(normal, random_point_on_sphere) < 0;
        ray_dir = below_horizon ? -ray_dir : ray_dir;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            origin.xyz,
            1.1,
            ray_dir.xyz,
            10000.0,
            0
        );

        const hit_payload_t first_surface = payload;
        if (first_surface.hit) {
            contribution += vec3(0.0, 0.0, 10.0);
            continue;

            for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                if (length(directional_light_dir) <= 0.1) {
                    continue;
                }

                //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                //    continue;
                //}

                // check for this directional light
                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsNoneEXT,
                    0xff,
                    0,
                    0,
                    0,
                    first_surface.position.xyz,
                    0.1,
                    directional_light_dir.xyz,
                    10000.0,
                    0
                );

                const hit_payload_t second_surface = payload;

                if (!second_surface.hit) {
                    // shadow ray is not occluded: sum the contribution of this point
                    const float coeff_directional_light = max(dot(first_surface.triangle_normal, directional_light_dir.xyz), 0.0);
                    const vec3 directional_light_effective_intensity = coeff_directional_light * directional_light_intensity;
                    const vec3 diffuse_contibution = directional_light_effective_intensity * first_surface.diffuse;
                    contribution += diffuse_contibution;
                } else {
                    // TODO: cast the final ray
                }
            }

            const float first_hit_coefficient = max(dot(first_surface.triangle_normal, ray_dir), 0.0);
            // from here one 
        } else
        // test for collisions (REMOVE ME)
        {
            contribution += vec3(10.0, 0.0, 0.0);
        }
    }

    imageStore(outputImage[0], texel_position, vec4(old_gi_data + (contribution / float(FIRST_PASS_RAYS)), 1.0));
    //imageStore(outputImage, texel_position, vec4(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0, 1.0));
}
