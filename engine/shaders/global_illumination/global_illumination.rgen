//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "payload.glsl"
#include "../sphere_points.glsl"

// keep this in sync with the rust side
#define MAX_DIRECTIONAL_LIGHTS 8

// just a stub
layout (set = 0, binding = 0, std430) readonly buffer tlas_instances
{
    uint data[];
};

layout (set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

// gbuffer: 0 for position, 1 for normal, 2 for diffuse texture
layout (set = 1, binding = 0) uniform sampler2D gbuffer[3];

struct light_t {
    float direction_x;
    float direction_y;
    float direction_z;

    float intensity_x;
    float intensity_y;
    float intensity_z;
};

layout(set = 2, binding = 1) uniform sampler2D dlbuffer[MAX_DIRECTIONAL_LIGHTS];
layout(std430, set = 2, binding = 0) readonly buffer directional_lights
{
    light_t light[];
};

uniform layout (set = 5, binding = 0, rgba32f) image2D outputImage;

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define FIRST_PASS_RAYS 12

void main() {
    const ivec2 resolution = imageSize(outputImage);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    const vec3 old_data = /*imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)).rgb*/ vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    for (uint ray_index_1 = 0; ray_index_1 < 1; ray_index_1++) {
        //const vec3 ray_dir = vec3(1.0, 0.0, 0.0);
        const vec3 random_point_on_sphere = vec3(-0.016828, 0.999740, -0.015416);
        vec3 ray_dir = reflect(normal, random_point_on_sphere);
        const bool below_horizon = dot(normal, random_point_on_sphere) < 0;
        ray_dir = below_horizon ? -ray_dir : ray_dir;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            origin.xyz,
            0.1,
            ray_dir.xyz,
            10000.0,
            0
        );

        const hit_payload_t first_surface = payload;
        if (first_surface.hit) {
            for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                if (length(directional_light_dir) <= 0.1) {
                    continue;
                }

                //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                //    continue;
                //}

                // check for this directional light
                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsNoneEXT,
                    0xff,
                    0,
                    0,
                    0,
                    first_surface.position.xyz,
                    0.1,
                    directional_light_dir.xyz,
                    10000.0,
                    0
                );

                const hit_payload_t second_surface = payload;

                if (!second_surface.hit) {
                    // shadow ray is not occluded: sum the contribution of this point
                    const float coeff_directional_light = max(dot(first_surface.triangle_normal, directional_light_dir.xyz), 0.0);
                    const vec3 directional_light_effective_intensity = coeff_directional_light * directional_light_intensity;
                    const vec3 diffuse_contibution = directional_light_effective_intensity * first_surface.diffuse;
                    contribution += diffuse_contibution;
                } else {
                    // TODO: cast the final ray
                }
            }

            const float first_hit_coefficient = max(dot(first_surface.triangle_normal, ray_dir), 0.0);
            // from here one 
        } else
        // test for collisions (REMOVE ME)
        {
            contribution += vec3(4.0, 4.0, 4.0);
        }
    }

    imageStore(outputImage, texel_position, vec4(old_data + (contribution / float(FIRST_PASS_RAYS)), 1.0));
    //imageStore(outputImage, texel_position, vec4(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0, 1.0));
}
