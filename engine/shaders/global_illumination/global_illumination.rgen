//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "../config.glsl"
#include "payload.glsl"
#include "random.glsl"
#include "morton.glsl"
#include "surfel.glsl"

layout (set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

struct light_t {
    float direction_x;
    float direction_y;
    float direction_z;

    float intensity_x;
    float intensity_y;
    float intensity_z;
};

layout(std140, set = 2, binding = 0) uniform camera_uniform {
	mat4 viewMatrix;
	mat4 projectionMatrix;
} camera;

layout(std430, set = 2, binding = 1) readonly buffer directional_lights
{
    light_t light[];
};

uniform layout (set = 5, binding = 2, rgba32f) image2D outputImage[2];

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#define FIRST_PASS_RAYS 8

layout(push_constant) uniform GIData {
    uint gi_reuse_frames;
} gi_data;

vec3 random_point_on_unit_sphere(inout uint state)
{
  float z = rnd(state) * 2.0 - 1.0;
  float t = rnd(state) * 6.28318530718; // 2 * PI
  float r = sqrt(1.0 - z * z);
  return vec3(r * cos(t), r * sin(t), z);
}

vec3 contribution(in vec3 surface_color, in float light_intensity, in float diffuse_coefficient)
{
    return surface_color * light_intensity * diffuse_coefficient;

}

#define MAX_RAY_DEPTH 2

#define DEPTH_IGNORE 2.0

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_LaunchIDEXT.xy);

    const vec3 old_gi_data = gi_data.gi_reuse_frames > 0 ? imageLoad(outputImage[0], ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0.0, 0.0, 0.0);

    const vec3 origin = texelFetch(gbuffer[0], texel_position, 0).xyz;
    const vec3 normal = texelFetch(gbuffer[1], texel_position, 0).xyz;
    const vec3 diffuse = texelFetch(gbuffer[2], texel_position, 0).xyz;
    const vec3 specular = texelFetch(gbuffer[3], texel_position, 0).xyz;
    const float depth = texture(gbuffer_depth, vec3(float(texel_position.x) / float(resolution.x), float(texel_position.y) / float(resolution.y), 1.0));

    const vec3 eye_position = vec3(camera.viewMatrix[3][0], camera.viewMatrix[3][1], camera.viewMatrix[3][2]);
    const vec3 view_dir = normalize(eye_position - origin);

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    // direct lighting: only compute it if the previous GI data cannot be reused
    if ((gi_data.gi_reuse_frames == 0) && (depth < DEPTH_IGNORE)) {
        vec3 lights_contribution = vec3(0.0, 0.0, 0.0);
        for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
            const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
            const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
            const vec3 ray_dir = -1.0 * light_dir;

            float diffuse_contribution = 0.0;
            float specular_contribution = 0.0;

            if (length(light_dir) > 0.1) {
                if (!(origin.x == 0 && origin.y == 0 && origin.z == 0)) {
                    // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                        0xff,
                        0,
                        0,
                        0,
                        origin.xyz,
                        1.0,
                        ray_dir.xyz,
                        10000.0,
                        0
                    );
                }

                if (!payload.hit) {
                    const float radius = 5.0;

                    diffuse_contribution = max(dot(normal, ray_dir), 0.0);
                    const vec3 diffuse = diffuse_contribution * light_intensity * diffuse;

                    const vec3 reflect_dir = reflect(-light_dir, normal);
                    specular_contribution = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
                    // TODO: here change diffuse texture with specular texture
                    const vec3 specular = specular_contribution * light_intensity * diffuse;

                    // TODO: here sum specular
                    lights_contribution += diffuse;

                    bool done = false;
                    uint checked_surfels = 0;
                    do {
                        // try to reuse an existing surfel
                        checked_surfels = allocated_surfels();
                        uint surfel_search_res = linear_search_surfel_for_allocation(checked_surfels, origin, radius);
                        if (surfel_search_res != SURFELS_MISSED) {
                            const uint surfel_id = surfel_search_res;

                            /*
                            // try locking the surfel
                            while (!lock_surfel(surfel_id)) {
                                // surfel is locked, try again
                                continue;
                            }
                            */

                            // surfel is locked: update it
                            //const vec3 surfel_diffuse = vec3(surfels[surfel_search_res].irradiance_r, surfels[surfel_search_res].irradiance_g, surfels[surfel_search_res].irradiance_b) / float(surfels[surfel_search_res].irradiance_samples);
                            //lights_contribution += contribution(surfel_diffuse, length(light_intensity), diffuse_contribution);

                            /*
                            // surfel is locked: unlock it for other instances
                            unlock_surfel(surfel_id);
                            memoryBarrierBuffer();
                            */
                            done = true;
                        } else {
                            // A matching surfel was not found: try to allocate a new one
                            uint surfel_id = allocate_surfel(checked_surfels);
                            if (surfel_id == SURFELS_FULL) {
                                done = true;
                            } else if (surfel_id == SURFELS_MISSED) {
                                checked_surfels = allocated_surfels();
                            } else {
                                init_surfel(surfel_id, payload.instance_id, origin, radius, normal, diffuse);
                                memoryBarrierBuffer();
                                done = true;
                            }
                        }
                    } while (!done);
                }
            }
        }

        imageStore(outputImage[1], texel_position, vec4(lights_contribution, 1.0));
    }

    hit_payload_t collisions[MAX_RAY_DEPTH];
    vec3 ray_directions[MAX_RAY_DEPTH];

    vec3 contribution = vec3(0.0, 0.0, 0.0);

    if ((depth < DEPTH_IGNORE) && (SHOW_SURFELS) && (gi_data.gi_reuse_frames == 2)) {
        const uint search_surfels = allocated_surfels();
        const uint surfel_id = linear_search_surfel_ignore_instance_id(search_surfels, origin);
        if (search_surfels > 322) {
            contribution = vec3(0, 300.0, 0.0);
        } else if (surfel_id == SURFELS_MISSED) {
            contribution = vec3(300.0, 0.0, 0.0);
        } else {
            contribution = vec3(0.0, 0.0, 300.0);
        }
    }

    uint casted_primary_rays = 0;
    uint ray_depth = 0;
    if (depth < DEPTH_IGNORE) {
        while ((ray_depth < MAX_RAY_DEPTH) && (!SHOW_SURFELS)) {
            // cast a ray in a random direction over the hemisphere oriented by the normal
            // accumulate the contribution of the ray if it hits something
            // if it hits nothing, stop
            // if it hits something, repeat
            if (casted_primary_rays == FIRST_PASS_RAYS) {
                break;
            }

            const vec3 random_point_on_sphere = random_point_on_unit_sphere(seed);
            vec3 ray_dir = reflect(normal, random_point_on_sphere);
            const bool below_horizon = dot(normal, random_point_on_sphere) < 0;
            ray_dir = below_horizon ? -ray_dir : ray_dir;

            ray_directions[ray_depth] = ray_dir;
            if (ray_depth == 0) {
                casted_primary_rays += 1;
            }

            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                ray_depth == 0 ? origin.xyz : collisions[ray_depth - 1].position.xyz,
                0.1,
                ray_directions[ray_depth].xyz,
                10000.0,
                0
            );

            collisions[ray_depth] = payload;

            if (collisions[ray_depth].hit) {
                // from the new point try to query all the directional lights
                for (uint dir_light_index = 0; dir_light_index < MAX_DIRECTIONAL_LIGHTS; dir_light_index++) {
                    const vec3 directional_light_dir = -1.0 * vec3(light[nonuniformEXT(dir_light_index)].direction_x, light[nonuniformEXT(dir_light_index)].direction_y, light[nonuniformEXT(dir_light_index)].direction_z);
                    const vec3 directional_light_intensity = vec3(light[nonuniformEXT(dir_light_index)].intensity_x, light[nonuniformEXT(dir_light_index)].intensity_y, light[nonuniformEXT(dir_light_index)].intensity_z);
                    if (length(directional_light_dir) <= 0.1) {
                        continue;
                    }

                    //if ((abs(directional_light_intensity.x) + abs(directional_light_intensity.y) + abs(directional_light_intensity.z)) <= 0.1)) {
                    //    continue;
                    //}

                    // check for this directional light
                    traceRayEXT(
                        topLevelAS,
                        gl_RayFlagsNoneEXT,
                        0xff,
                        0,
                        0,
                        0,
                        collisions[ray_depth].position,
                        0.1,
                        directional_light_dir,
                        10000.0,
                        0
                    );

                    // shadow ray is not occluded: sum the contribution of this point
                    if (!payload.hit) {
                        // when calculating directional light contribution, account for the entire path
                        // the light has been reflected at each bounce according to the diffuse coefficient
                        // (so the contribution is attenuated at each bounce)
                        // also account for the angle of incidence of the light on each surface (Lambertian
                        // reflectance):
                        //
                        // To do this associate the diffuse texture and normal of the last SURELY hit surface collisions[ray_depth-1]
                        // (or "diffuse" and "normal" in case ray_depth is 0), and the ray_direction at that point collisions[ray_depth]
                        // (or directional_light_dir if ray_depth is )

                        vec3 incoming_diffuse_light = directional_light_intensity;
                        uint r = ray_depth;
                        while (1 == 1) {
                            vec3 surface_normal = r == 0 ? normal : collisions[r].triangle_normal;
                            vec3 surface_diffuse = r == 0 ? diffuse : collisions[r].diffuse;
                            vec3 surface_ray = r == ray_depth ? directional_light_dir : ray_directions[r + 1];

                            incoming_diffuse_light *= max(dot(surface_normal, surface_ray), 0.0) * surface_diffuse;

                            if (r == 0) {
                                break;
                            } else {
                                r -= 1;
                            }
                        }

                        contribution += incoming_diffuse_light;
                        //contribution += vec3(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0);
                    }

                }
            }

            // no surface hit: restart from the beginning
            if (collisions[ray_depth].hit) {
                ray_depth++;
            } else {
                ray_depth = 0;
            }
        }
    }

    const float reused_scale = gi_data.gi_reuse_frames > 0 ? 2.0 : 1.0;
    imageStore(outputImage[0], texel_position, vec4((old_gi_data / 2.0) + (contribution / (float(FIRST_PASS_RAYS) * reused_scale)), 1.0));
    //imageStore(outputImage, texel_position, vec4(float(texel_position.x)/resolution.x, float(texel_position.y)/resolution.y, 0.0, 1.0));
}
