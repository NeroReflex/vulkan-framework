//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define BVH_IS_READONLY
#define DISCOVERED_IS_READONLY
#define SURFELS_DESCRIPTOR_SET 4
#include "../surfel.glsl"

#define RT_DESCRIPTOR_SET 0
#include "../rt_descriptor_set.glsl"

#define STATUS_DESCRIPTOR_SET 1
#include "../status.glsl"

layout(location = 0) rayPayloadEXT hit_payload_t payload;

// WARNING: this MUST be a power of two!
#define FIRST_PASS_RAYS 8

#define BIAS_PARAM 0.5

#define MAX_RAY_DEPTH 2

#define DEPTH_IGNORE 1.0

void main() {
    // we have already accumulated enough frames: do nothing
    if (gi_data.gi_reuse_frames >= 0xFFFFFFFEu) {
        return;
    }

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    // load the surfel and terminate the shader if no surfel is found
    if (gl_LaunchIDEXT.x >= count_discoveder_surfels()) {
        return;
    }

    const uint surfel_id = discovered[gl_LaunchIDEXT.x];
    //debugPrintfEXT("evaluating surfel_id %u %u/%u\n", surfel_id, gl_LaunchIDEXT.x, count_discoveder_surfels());

    if (!IS_SURFEL_VALID(surfel_id)) {
        debugPrintfEXT("Invalid surfel_id %u detected!!!", surfel_id);
    }

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    vec3 contribution = vec3(0.0, 0.0, 0.0);
    uint contribution_samples = 0;

    const vec3 surfel_position = surfelPosition(surfel_id);
    const vec3 surfel_normal = surfelNormal(surfel_id);
    uint casted_primary_rays = 0;
    while (casted_primary_rays < FIRST_PASS_RAYS) {
        casted_primary_rays++;

        // cast a ray in a random direction over the hemisphere oriented by the normal
        // accumulate the contribution of the ray if it hits something
        // if it hits nothing, stop
        // if it hits something, repeat
        const vec3 random_point_on_sphere = random_point_on_unit_sphere(seed);
        vec3 ray_dir = reflect(surfel_normal, random_point_on_sphere);
        ray_dir = is_below_horizon(surfel_normal, random_point_on_sphere) ? -ray_dir : ray_dir;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsNoneEXT,
            0xff,
            0,
            0,
            0,
            surfel_position,
            CLOSEST_INTERSECTION_DISTANCE,
            ray_dir,
            10000.0,
            0
        );

        // store the RT result
        const hit_payload_t primary_payload = payload;

        // no surface was hit: continue with the primary rays work
        if (!primary_payload.hit) {
            continue;
        }

        // query for surfel existance in the intersection point
        bool fresh_allocation = false;
        const uint intersected_surfel = find_surfel_or_allocate_new(
            eye_position,
            clip_planes,
            primary_payload.instance_id,
            primary_payload.position,
            primary_payload.triangle_normal,
            primary_payload.diffuse,
            true,
            fresh_allocation
        );

        // No surfel was either hit or freshly allocated: continue with the primary rays work
        if (!IS_SURFEL_VALID(intersected_surfel)) {
            continue;
        }

        // The surfel has been allocated with allocate_locked=true
        // and MUST be unlocked before use, however the rule of
        // "who spawns the surfel also calculates the received direction lighting"
        // from the previous pass surfel_spawn holds true in this shader too!
        if (fresh_allocation) {
            // done only once per surfel (at the spawn) calculate incoming directional lighting
            vec3 surfel_received_direction_light = vec3(0.0, 0.0, 0.0);
            for (uint light_index = 0; light_index < MAX_DIRECTIONAL_LIGHTS; light_index++) {
                const vec3 light_intensity = vec3(light[light_index].intensity_x, light[light_index].intensity_y, light[light_index].intensity_z);
                const vec3 light_dir = vec3(light[light_index].direction_x, light[light_index].direction_y, light[light_index].direction_z);
                const vec3 ray_dir = -1.0 * light_dir;
                if (length(light_dir) < 0.4) {
                    continue;
                }

                // other flags: gl_RayFlagsCullNoOpaqueEXT gl_RayFlagsNoneEXT
                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsSkipAABBEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsCullNoOpaqueEXT,
                    0xff,
                    0,
                    0,
                    0,
                    surfelPosition(intersected_surfel),
                    CLOSEST_INTERSECTION_DISTANCE,
                    ray_dir.xyz,
                    10000.0,
                    0
                );

                const float diffuse_contribution = max(dot(surfelNormal(intersected_surfel), ray_dir), 0.0);
                surfel_received_direction_light += diffuse_contribution * light_intensity;
            }

            // Register incoming directional lighting to the surfel
            addDirectionalLightContribution(surfel_id, surfel_received_direction_light);

            unlock_surfel(intersected_surfel);
            memoryBarrierBuffer();
        }

/*
        uint ray_depth = 0;
        hit_payload_t collisions[MAX_RAY_DEPTH];
        vec3 ray_directions[MAX_RAY_DEPTH];
        while (ray_depth < MAX_RAY_DEPTH) {
            // no surface hit: restart from the beginning
            if (collisions[ray_depth].hit) {
                ray_depth++;
            } else {
                ray_depth = 0;
            }
        }
*/
    }


}
