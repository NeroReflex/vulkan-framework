//#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define BVH_IS_READONLY
#define DISCOVERED_IS_READONLY
#define SURFELS_DESCRIPTOR_SET 4
#include "../surfel.glsl"

#define RT_DESCRIPTOR_SET 0
#include "../rt_descriptor_set.glsl"

#define STATUS_DESCRIPTOR_SET 1
#include "../status.glsl"

layout(location = 0) rayPayloadEXT hit_payload_t payload;

#include "../rt_helpers.glsl"

// WARNING: this MUST be a power of two!
#define FIRST_PASS_RAYS 8

#define BIAS_PARAM 0.5

#define MAX_RAY_DEPTH 2

#define DEPTH_IGNORE 1.0

void main() {
    // we have already accumulated enough frames: do nothing
    if (gi_data.gi_reuse_frames >= 0xFFFFFFFEu) {
        return;
    }

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    const uvec2 resolution = imageSize(outputImage[0]);

#if POPULATE_VISIBLE_SURFELS_LIST
    const uint global_id = (resolution.x * gl_LaunchIDEXT.y) + gl_LaunchIDEXT.x;

    // load the surfel and terminate the shader if no surfel is found
    if (global_id >= count_discoveder_surfels()) {
        return;
    }

    const uint surfel_id = discovered[global_id];
    //debugPrintfEXT("evaluating surfel_id %u %u/%u\n", surfel_id, gl_LaunchIDEXT.x, count_discoveder_surfels());

    if (!IS_SURFEL_VALID(surfel_id)) {
        debugPrintfEXT("Invalid surfel_id %u detected!!!", surfel_id);
    }

    // This is MY surfel! I have the right to work on it!
    bool locked = false;
    do {
        locked = lock_surfel(surfel_id);
    } while (!locked);
#else
    const uint surfel_id = imageLoad(surfelOverlappingImage, ivec2(gl_LaunchIDEXT.xy)).r;

    // the shader only works (logically) if the base surfel is valid and locked
    if ((!IS_SURFEL_VALID(surfel_id)) || (!lock_surfel(surfel_id))) {
        return;
    }
#endif

    const vec3 base_surfel_position = surfelPosition(surfel_id);
    const vec3 base_surfel_normal = surfelNormal(surfel_id);

    // Initialize the random number
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gi_data.gi_reuse_frames);

    vec3 contribution = vec3(0.0);
    uint contribution_samples = 0;

    uint casted_primary_rays = surfels[surfel_id].frame_contributions;
    while (casted_primary_rays < FIRST_PASS_RAYS) {
        casted_primary_rays++;

        // Recursively trace rays up to MAX_RAY_DEPTH: if no surfel is hit
        // spawn a new surfel and stop, if a surfel is hit, continue.
        // 
        // WARNING: when the for exits this is the number of currently locked surfels.
        // a surfel can only contribute if its lock is held, otherwise I might perform
        // incoherent reads/writes on the surfel data!
        uint ray_depth = 0;
        hit_payload_t collisions[MAX_RAY_DEPTH];
        uint surfels_hit[MAX_RAY_DEPTH];
        while (ray_depth < MAX_RAY_DEPTH) {
            const vec3 ray_dir = random_ray_above_horizon(ray_depth == 0 ? base_surfel_normal : collisions[ray_depth - 1].triangle_normal, seed);
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsNoneEXT,
                0xff,
                0,
                0,
                0,
                ray_depth == 0 ? base_surfel_position : collisions[ray_depth - 1].position,
                CLOSEST_INTERSECTION_DISTANCE,
                ray_dir,
                10000.0,
                0
            );

            // store the RT result
            collisions[ray_depth] = payload;

            // no surface was hit: continue with the primary rays work
            if (!collisions[ray_depth].hit) {
                break;
            }

            // query for surfel existance in the intersection point
            bool fresh_allocation = false;
            const uint intersected_surfel_id = find_surfel_or_allocate_new(
                eye_position,
                clip_planes,
                collisions[ray_depth].instance_id,
                collisions[ray_depth].position,
                collisions[ray_depth].triangle_normal,
                collisions[ray_depth].diffuse,
                true,
                fresh_allocation
            );

            // No surfel was either hit or freshly allocated: continue with the primary rays work
            if (!IS_SURFEL_VALID(intersected_surfel_id)) {
                break;
            }

            // The surfel has been allocated with allocate_locked=true
            // and MUST be unlocked before use, however the rule of
            // "who spawns the surfel also calculates the received directional lighting"
            // from the previous pass surfel_spawn holds true in this shader too!
            if (fresh_allocation) {
                // done only once per surfel (at the spawn) calculate incoming directional lighting
                const vec3 surfel_received_direction_light = rt_directional_light(intersected_surfel_id);

                // Register incoming directional lighting to the surfel
                addDirectionalLightContribution(surfel_id, surfel_received_direction_light);
            }

            // if the surfel is not locked already (because it was freshly allocated)
            // or if I failed to lock it, stop the search here
            if ((!fresh_allocation) && (!lock_surfel(intersected_surfel_id))) {
                break;
            }

            // this surfel has contributed to the current frame: keep it aslive
            surfels[intersected_surfel_id].latest_contribution = 0;

            // store the surfel and continue
            surfels_hit[ray_depth++] = intersected_surfel_id;
        }

        // sum this contribution to the surfel
        if (ray_depth > 0) {
            surfels[surfel_id].frame_contributions++;
        }

        // Run the previous for backward, accumulating the contribution
        // and updating the surfels along the way.
        // WARNING: in order to avoid deadlocks/starvations it is imperative
        // that surfels are unlocked in the reverse order they were locked!
        for (uint i = ray_depth; i > 0; i--) {
            if (i > 1) {
                // project the contribution of the surfel i to i - 1,
                // store the contribution and increment the sample count
                const uint emitter_surfel = surfels_hit[i - 1];
                const uint receiver_surfel = surfels_hit[i - 2];

                const vec3 emitter_position = surfelPosition(emitter_surfel);
                const vec3 emitter_normal = surfelNormal(emitter_surfel);
                const vec3 receiver_position = surfelPosition(receiver_surfel);
                const vec3 receiver_normal = surfelNormal(receiver_surfel);

                const vec3 received_light = projected_irradiance(
                    emitter_surfel,
                    receiver_position,
                    receiver_normal
                );
            } else {
                // store the contribution of the last "random" surfel in the chain
                // to be later applied to the current surfel
                const uint emitter_surfel = surfels_hit[0];

                const vec3 emitter_position = surfelPosition(emitter_surfel);
                const vec3 emitter_normal = surfelNormal(emitter_surfel);

                const vec3 received_light = projected_irradiance(
                    emitter_surfel,
                    base_surfel_position,
                    base_surfel_normal
                );

                contribution_samples++;
                contribution += received_light;
            }
        }

        // Ensure others threads see the updated surfel data:
        // perform the update while holding locks!
        memoryBarrierBuffer();

        // TODO: unlock all surfels that were locked
        while (ray_depth > 0) {
            unlock_surfel(surfels_hit[ray_depth - 1]);
            ray_depth--;
        }
    }

    // I am done with my surfel: unlock it    
    unlock_surfel(surfel_id);
}
