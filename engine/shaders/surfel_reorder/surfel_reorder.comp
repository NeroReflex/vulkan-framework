#extension GL_EXT_debug_printf : enable

#include "../config.glsl"

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define SURFELS_DESCRIPTOR_SET 1
#include "../surfel.glsl"

// Basically a counting sort: each surfel computes its new index by counting how many surfels
// have a smaller morton code than itself.
//
// In this context ordered surfels are not yet ordered: they are just in the second half of the buffer.
// This shader MUST NOT rely on the correctness of unordered_surfels, as it will be updated by the current shader.
void main() {
    const uint size = count_ordered_surfels();
    const uint half_size = total_surfels / 2;
    const uint surfel_id = gl_GlobalInvocationID.x;

    // This is a bit of a hack to clear unordered_surfels,
    // but if it works it works.
    if (gl_GlobalInvocationID.x == 0) {
        // clearing unordered_surfels has the effect of allowing new surfels to be allocated
        // since unordered_surfels is used by the raytracing pipeline to track how many surfels
        // have been allocated on a single frame.
        atomicAnd(unordered_surfels, 0);
        atomicAnd(active_surfels, 0);
        atomicMax(active_surfels, int(count_ordered_surfels()));

        // DEBUG OUTPUT
        // =========================================
        //int merda = atomicMax(ordered_surfels, 0);
        //if (merda == 0) {
        //    // no surfels to reorder
        //    debugPrintfEXT("reorder.comp: no surfels to reorder: %d\n", merda);
        //} else if (merda < 0) {
        //    debugPrintfEXT("reorder.comp: something went really wrong!!!: %d\n", merda);
        //    atomicAdd(ordered_surfels, (merda * -1) + 1); // restore the previous value
        //} else {
        //    debugPrintfEXT("reorder.comp: reordering %d surfels\n", merda);
        //}
        // =========================================
    }

    if (gl_GlobalInvocationID.x < MAX_USABLE_SURFELS) {
        // clear the discovered surfels list to allow new surfels to be discovered
        atomicOr(discovered[gl_GlobalInvocationID.x], USED_SURFEL_MISSING);
    }

    // avoid out-of-bounds access
    if (surfel_id >= size) {
        return;
    } 

    const uint src_surfel_id = half_size + surfel_id;
    const uint surfel_morton = surfels[src_surfel_id].morton;
    //debugPrintfEXT("reorder.comp: surfel_id=%u morton=%u\n", surfel_id, surfel_morton);

    // compute the new offset for the surfel
    uint ordered_surfel_id = 0;
    for (uint i = half_size; i < half_size + size; i++) {
        const uint current_surfel_morton = surfels[i].morton;
        if (current_surfel_morton < surfel_morton) {
            ordered_surfel_id += 1;
        } else if ((current_surfel_morton == surfel_morton) && (i < src_surfel_id)) {
            // this is to ensure a stable sort: surfels with the same morton code keep their relative order
            ordered_surfel_id += 1;
        }
    }

    // copy the surfel to the new location
    surfels[ordered_surfel_id] = surfels[src_surfel_id];
    //memoryBarrierBuffer();
    //if (gl_GlobalInvocationID.x < 8) {
    //    debugPrintfEXT("reorder.comp: src_id=%u ordered_id=%u morton=%u\n", src_surfel_id, ordered_surfel_id, surfel_morton);
    //}
}
