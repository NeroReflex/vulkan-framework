#extension GL_EXT_debug_printf : enable

#include "../config.glsl"

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define SURFELS_DESCRIPTOR_SET 1
#include "../surfel.glsl"

// Update the morton code of all surfels, moving them into the unordered set.
//
// In this context ordered surfels are not yet ordered:
// they are just sitting in the first half of the buffer,
// waiting to be copied on the second half of the buffer,
// AFTER the unordered surfels that already are in the second
// half of the buffer because they were written in the previous
// global illumination pass.
void main() {
    // in this pass NEVER rely on the correctness of ordered_surfels:
    // I am updating it as I go, and it is not safe to read it.
    //
    // In contrast, unordered_surfels is a constant (readonly) in this pass.
    const uint unordered_size = count_unordered_surfels();

    // Avoid overwriting surfels that have been written in the previous frame:
    // Those that are called "unordered"
    const uint half_size = total_surfels / 2;

    const vec2 clip_space = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    // Increment the number of ordered surfels: those were allocated the previous frame
    // and will be left in place for the reordering shader.
    //
    // Since this pass NEVER relies on ordered_surfels it is safe to modify it.
    // The next pass will see the correct value.
    if (gl_GlobalInvocationID.x < unordered_size) {
        // We also need to update the morton code of these surfels that are kept in place
        const uint src_surfel_id = half_size + gl_GlobalInvocationID.x;
        const vec3 surfel_center = vec3(surfels[src_surfel_id].position_x, surfels[src_surfel_id].position_y, surfels[src_surfel_id].position_z);
        const uint morton = surfels[src_surfel_id].morton == MORTON_OUT_OF_SCALE ? MORTON_OUT_OF_SCALE : morton3D(eye_position, surfel_center, clip_space);
        surfels[src_surfel_id].morton = morton;

        // this is a just spawned surfel: it hasn't contributed yet
        // to the final image, so reset its contribution counter
        // (it will be incremented later if it contributes)
        surfels[src_surfel_id].latest_contribution = 0;
        uint old_value = atomicAdd(ordered_surfels, 1);
        //debugPrintfEXT("updated %u pos=(%f,%f,%f) increment ordered_surfels from %u in shader %u/%u\n", src_surfel_id, surfel_center.x, surfel_center.y, surfel_center.z, old_value, gl_GlobalInvocationID.x, unordered_size);
    }

    // I have nothing to do
    if (gl_GlobalInvocationID.x >= (half_size - unordered_size)) {
        return;
    }

    const uint src_surfel_id = gl_GlobalInvocationID.x;
    const uint dst_surfel_id = half_size + unordered_size + gl_GlobalInvocationID.x;

    // The morton code can be MORTON_OUT_OF_SCALE: these will be removed in the sorting step
    const vec3 surfel_center = vec3(surfels[src_surfel_id].position_x, surfels[src_surfel_id].position_y, surfels[src_surfel_id].position_z);
    
    // if previous morton was MORTON_OUT_OF_SCALE, keep it that way (so that surfels that were out of scale will get removed later)
    const uint morton = surfels[src_surfel_id].morton == MORTON_OUT_OF_SCALE ? MORTON_OUT_OF_SCALE : morton3D(eye_position, surfel_center, clip_space);

    // copy the surfel to the new location with updated morton code
    surfels[dst_surfel_id] = surfels[src_surfel_id];
    surfels[dst_surfel_id].morton = morton;
    surfels[src_surfel_id].latest_contribution += 1;

#if DELETE_NOT_CONTRIBUTING_SURFELS
    if (surfels[src_surfel_id].latest_contribution == DELETE_NOT_CONTRIBUTING_SURFELS) {
        // this surfel hasn't contributed to the final image in a while: delete it
        surfels[dst_surfel_id].morton = MORTON_OUT_OF_SCALE;
        //debugPrintfEXT("morton.comp: deleting surfel %u\n", src_surfel_id);
    }
#endif

    //if (src_surfel_id < 8) {
    //    debugPrintfEXT("morton.comp: src_id=%u dst_id=%u pos=(%f,%f,%f) morton=%u\n", src_surfel_id, dst_surfel_id, surfel_center.x, surfel_center.y, surfel_center.z, morton);
    //}
    //memoryBarrierBuffer();
}
