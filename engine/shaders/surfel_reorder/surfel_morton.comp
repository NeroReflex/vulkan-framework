#extension GL_EXT_debug_printf : enable

#include "../config.glsl"

// SURFELS_MORTON_GROUP_SIZE_X must match the Rust side
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define SURFELS_DESCRIPTOR_SET 1
#include "../surfel.glsl"

// Update the morton code of all surfels, moving them into the unordered set.
//
// In this context ordered surfels are not yet ordered:
// they are just sitting in the first half of the buffer,
// waiting to be copied on the second half of the buffer,
// AFTER the unordered surfels that already are in the second
// half of the buffer because they were written in the previous
// global illumination pass.
void main() {
    // in this pass NEVER rely on the correctness of ordered_surfels:
    // I am updating it as I go, and it is not safe to read it.
    //
    // In contrast, unordered_surfels is a constant (readonly) in this pass.
    const uint unordered_size = count_unordered_surfels();

    // Avoid overwriting surfels that have been written in the previous frame:
    // Those that are called "unordered"
    const uint half_size = total_surfels / 2;

    //if (gl_GlobalInvocationID.x == 0) {
    //    debugPrintfEXT("morton.comp: START unordered_size=%u ordered_surfels=%u active_surfels=%u half_size=%u total_surfels=%u\n", unordered_size, ordered_surfels, active_surfels, half_size, total_surfels);
    //}

    const vec2 clip_space = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    // Increment the number of ordered surfels: those were allocated the previous frame
    // and will be left in place for the reordering shader.
    //
    // Since this pass NEVER relies on ordered_surfels it is safe to modify it.
    // The next pass will see the correct value.
    if (gl_GlobalInvocationID.x < unordered_size) {
        // We also need to update the morton code of these surfels that are kept in place
        const uint src_surfel_id = half_size + gl_GlobalInvocationID.x;
        const vec3 surfel_center = surfelPosition(src_surfel_id);
        surfels[src_surfel_id].morton = morton3D(eye_position, surfel_center, clip_space);

        // this is a just spawned surfel: it hasn't contributed yet
        // to the final image, so reset its contribution counter
        // (it will be incremented later if it contributes)
        surfels[src_surfel_id].latest_contribution = 0;

        atomicAdd(ordered_surfels, 1);
    }

    // I have nothing to do: if The following code would execute I would copy
    // a surfel into potentially out-of-bound memory
    if (gl_GlobalInvocationID.x >= active_surfels) {
        return;
    }

    // to delete surfels that are out of scale I count how many there are before the current one:
    // the counting is done in the read-only memory portion: the one with previously-ordered surfels
    uint how_many_out_of_scale_before_me = 0;
    for (uint i = 0; i < gl_GlobalInvocationID.x; i++) {
        if (surfels[i].morton == MORTON_OUT_OF_SCALE) {
            how_many_out_of_scale_before_me += 1;
        }
    }

    // subtracting how many surfels before me are out of scale gives me the "compacted" index
    const uint src_surfel_id = gl_GlobalInvocationID.x;
    const uint dst_surfel_id = half_size + unordered_size + (gl_GlobalInvocationID.x - how_many_out_of_scale_before_me);

    // The morton code can be MORTON_OUT_OF_SCALE: these will be removed in the sorting step
    const vec3 surfel_center = vec3(surfels[src_surfel_id].position_x, surfels[src_surfel_id].position_y, surfels[src_surfel_id].position_z);

    // if previous morton was MORTON_OUT_OF_SCALE, keep it that way (so that surfels that were out of scale will get removed later)
    if (surfels[src_surfel_id].morton != MORTON_OUT_OF_SCALE) {
        // copy the surfel to the new location with updated morton code
        surfels[dst_surfel_id] = surfels[src_surfel_id];
        surfels[dst_surfel_id].morton = morton3D(eye_position, surfel_center, clip_space);
        surfels[dst_surfel_id].latest_contribution += 1;

#if DELETE_NOT_CONTRIBUTING_SURFELS
        if (surfels[dst_surfel_id].latest_contribution >= DELETE_NOT_CONTRIBUTING_SURFELS) {
            // this surfel hasn't contributed to the final image in a while: delete it
            surfels[dst_surfel_id].morton = MORTON_OUT_OF_SCALE;
            //debugPrintfEXT("morton.comp: marking for later deletion surfel %u\n", src_surfel_id);
        }
#endif

        // if the surfel radius is disproportionate with its distance from the camera, delete it
        const float ideal_radius = radius_from_camera_distance(eye_position, clip_space, surfel_center);
        if (abs(ideal_radius - surfels[src_surfel_id].radius) > DELETE_ON_RADIUS_DIFFERENCE) {
            //debugPrintfEXT("morton.comp: marking for later deletion surfel %u (radius=%f ideal_radius=%f)\n", src_surfel_id, surfels[src_surfel_id].radius, ideal_radius);
            
            // this surfel is out of scale: delete it
            surfels[dst_surfel_id].morton = MORTON_OUT_OF_SCALE;
        }
    } else {
        // decrement the number of ordered surfels: the next shader will use this
        // number as the number of surfels to reorder
        atomicAdd(ordered_surfels, -1);

        //debugPrintfEXT("morton.comp: DELETE: surfel[%u].morton=%u, invocation=%u, ordered_surfels(before)=%d, how_many_out_of_scale_before_me=%u\n",
        //    src_surfel_id,
        //    surfels[src_surfel_id].morton,
        //    gl_GlobalInvocationID.x,
        //    previous_value,
        //    how_many_out_of_scale_before_me
        //);
    }

    //if (src_surfel_id < 8) {
    //    debugPrintfEXT("morton.comp: src_id=%u dst_id=%u pos=(%f,%f,%f) morton=%u\n", src_surfel_id, dst_surfel_id, surfel_center.x, surfel_center.y, surfel_center.z, morton);
    //}
    //memoryBarrierBuffer();
}
