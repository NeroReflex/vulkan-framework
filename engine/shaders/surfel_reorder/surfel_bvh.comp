#extension GL_EXT_debug_printf : enable

// This algorithm is a modified version of https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu

#include "../config.glsl"

// Keep in sync with SURFELS_BVH_GROUP_SIZE_X
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define SURFELS_DESCRIPTOR_SET 1
#include "../surfel.glsl"

// low is x, high is y
#define uint64_t uvec2
#define new_uint64_from_uint(u) uint64_t(u, 0u)
#define new_uint64(low, high) uint64_t(low, high)

uint64_t rightShift(uint64_t value, uint shift) {
    if (shift >= 64u) {
        return new_uint64_from_uint(0u); // Shift out all bits
    } else if (shift >= 32u) {
        // shift >=32: high part moves into low
        uint s = shift - 32u;
        uint newLow = (value.y >> s);
        uint newHigh = 0u;
        return new_uint64(newLow, newHigh);
    } else {
        // shift <32: low becomes (low >> s) | (high << (32-s)), high becomes high >> s
        uint s = shift;
        uint newLow = (value.x >> s) | (value.y << (32u - s));
        uint newHigh = (value.y >> s);
        return new_uint64(newLow, newHigh);
    }
}

uint64_t leftShift(uint64_t value, uint shift) {
    if (shift >= 64u) {
        return new_uint64_from_uint(0u); // Shift out all bits
    } else if (shift >= 32u) {
        uint s = shift - 32u;
        // low becomes 0, high becomes low << s
        uint newLow = 0u;
        uint newHigh = (value.x << s);
        return new_uint64(newLow, newHigh);
    } else {
        // shift <32: low = low << s; high = (high << s) | (low >> (32-s))
        uint s = shift;
        uint newLow = (value.x << s);
        uint newHigh = (value.y << s) | (value.x >> (32u - s));
        return new_uint64(newLow, newHigh);
    }
}

uint64_t bitwiseAnd(uint64_t a, uint64_t b) {
    return new_uint64(a.x & b.x, a.y & b.y);
}

uint64_t bitwiseXor(uint64_t a, uint64_t b) {
    return new_uint64(a.x ^ b.x, a.y ^ b.y);
}

uint64_t bitwiseOr(uint64_t a, uint64_t b) {
    return new_uint64(a.x | b.x, a.y | b.y);
}

// Build a mask with single bit set at position k (0 = LSB, 63 = MSB)
uint64_t mask64_at(int k) {
    if (k < 0) return new_uint64_from_uint(0u);
    if (k < 32) {
        return new_uint64((1u << uint(k)), 0u);
    } else {
        return new_uint64(0u, (1u << uint(k - 32)));
    }
}

// Count leading zeros of a uint64 represented as uvec2(low, high)
int clz64(uint64_t v) {
    // check high part first (bits 63..32)
    if (v.y != 0u) {
        // leading zeros = number of zeros before the highest 1 in high (32-bit)
        // Use a 32-bit loop or builtin if available:
        for (int i = 31; i >= 0; --i) {
            if ((v.y & (1u << uint(i))) != 0u) {
                return 31 - i; // zeros before this bit within high
            }
        }
        // unreachable
        return 0;
    } else {
        // high == 0 -> leading zeros include 32 bits of high + clz(low)
        if (v.x == 0u) {
            return 64; // all zero
        }
        for (int i = 31; i >= 0; --i) {
            if ((v.x & (1u << uint(i))) != 0u) {
                return 32 + (31 - i);
            }
        }
        return 64;
    }
}

// Fetch the number of splits in a given range of surfels:
// split happens when the next surfel changes a bit higher
int fetch_splits(uint start, uint size) {
    uint first_index = start;
    uint last_index = start + size - 1;

    uint morton_of_first = surfels[first_index].morton;
    uint morton_of_last = surfels[last_index].morton;

    uint morton_xor = morton_of_first ^ morton_of_last;
    if (morton_xor == 0) {
        return -1;
    }

    uint bit_changed = 0;
    for (uint b = 1u << 31; b != 0; b >>= 1) {
        if ((morton_xor & b) != 0) {
            bit_changed = b;
            break;
        }
    }

    uint lo = start;
    uint hi = start + size; // one-past-end
    uint tmp = (morton_of_first & bit_changed);
    while (lo < hi) {
        uint mid = lo + ((hi - lo) >> 1);
        uint v = surfels[mid].morton;

        bool diff = (v & bit_changed) != tmp;
        if (!diff) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }

/*
    // linar search of the first surfel that changes the interesting bit
    for (uint i = 0; i <= last_index; i++) {
        if ((surfels[i].morton & bit_changed) != (morton_of_first & bit_changed)) {
            return i;
        }
    }
*/
    return int(lo);
}

int delta(int i, int j, const uint surfels_count)
{
    if (i < 0 || j < 0 || i >= int(surfels_count) || j >= int(surfels_count)) {
        return -1;
    }

    const uint64_t key_i = new_uint64_from_uint(surfels[i].morton);
    const uint64_t key_j = new_uint64_from_uint(surfels[j].morton);

    const uint64_t composed_key_i = bitwiseOr(leftShift(key_i, 32u), new_uint64_from_uint(uint(i)));
    const uint64_t composed_key_j = bitwiseOr(leftShift(key_j, 32u), new_uint64_from_uint(uint(j)));

    const uint64_t x = bitwiseXor(composed_key_i, composed_key_j);

    // If x == 0 -> keys identical -> leading zeros = 64
    if (x.x == 0u && x.y == 0u) {
        return 64;
    }

    int lz = clz64(x);
    return lz;
}

vec2 determineRange(const int index_internal_nodes, const uint numberOfTriangles)
{
    const int dleft = delta(index_internal_nodes, index_internal_nodes - 1, numberOfTriangles);
    const int dright = delta(index_internal_nodes, index_internal_nodes + 1, numberOfTriangles);

    // Determine direction of the range (+1 or -1)
    const int direction = sign(dright - dleft);

    // Compute upper bound for the length of the range
    const int delta_min = (direction == 1) ? dleft : dright;

    int l_max = 2;

    while (delta(index_internal_nodes, index_internal_nodes + l_max * direction, numberOfTriangles) > delta_min)
    {
        l_max *= 2;
    }

    int l = 0;

    // Find the other end using binary search
    for (int t = l_max / 2; t >= 1; t /= 2)
    {
        if (delta(index_internal_nodes, index_internal_nodes + (l + t) * direction, numberOfTriangles) > delta_min)
        {
            l += t;
        }
    }

    int j = index_internal_nodes + l * direction;

    return vec2(
        min(index_internal_nodes, j),
        max(index_internal_nodes, j)
    );
}

int findSplit(const int first, const int last, const uint count)
{
    const int commonPrefix = delta(first, last, count);

    int split = first;
    int step = last - first;

    do
    {
        step = (step + 1) >> 1;      // exponential decrease
        int newSplit = split + step; // proposed new position

        if (newSplit < last)
        {
            int splitPrefix = delta(first, newSplit, count);
            if (splitPrefix > commonPrefix)
                split = newSplit; // accept proposal
        }
    } while (step > 1);

    return split;
}

void main() {
    const uint index_internal_nodes = gl_GlobalInvocationID.x;

    const uint surfels_count = count_ordered_surfels();

    // initialize the root node as parent=0, left=0, right=0
    // if it is when needed it means the tree is empty.
    if (index_internal_nodes == 0) {
        tree[index_internal_nodes].parent = 0;
        tree[index_internal_nodes].left = 0;
        tree[index_internal_nodes].right = 0;
        memoryBarrierBuffer();
    }

    if (surfels_count == 0) {
        return;
    }

    // prepare the synchronization structure for the next step
    uint tmp = atomicMin(discovered[index_internal_nodes], 0);

    if (index_internal_nodes >= (surfels_count - 1)) {
        return;
    }

    const vec2 range = determineRange(int(index_internal_nodes), surfels_count);

    const int first_without_offset = int(range.x);
    const int last_without_offset = int(range.y);

    const int split_without_offset = findSplit(first_without_offset, last_without_offset, surfels_count);

    const uint split = split_without_offset;
    const uint first = uint(first_without_offset);
    const uint last = uint(last_without_offset);

    // Determine if left and right children are leaves or internal nodes
    bool leftIsLeaf = (split == first);
    bool rightIsLeaf = ((split + 1) == last);

    // Set left child
    if (leftIsLeaf) {
        tree[index_internal_nodes].left = split | NODE_IS_LEAF_FLAG;
    } else {
        tree[index_internal_nodes].left = split;
    }

    // Set right child  
    if (rightIsLeaf) {
        tree[index_internal_nodes].right = (split + 1) | NODE_IS_LEAF_FLAG;
    } else {
        tree[index_internal_nodes].right = split + 1;
    }

    // make sure the parent of a root node is the root node itself!
    if (index_internal_nodes == 0) {
        tree[index_internal_nodes].parent = index_internal_nodes;
        memoryBarrierBuffer(); // Ensure root parent assignment is visible
    }

    AABB leftAABB = compatAABB(
        vec3(POSITIVE_INF, POSITIVE_INF, POSITIVE_INF),
        vec3(NEGATIVE_INF, NEGATIVE_INF, NEGATIVE_INF)
    );

    AABB rightAABB = compatAABB(
        vec3(POSITIVE_INF, POSITIVE_INF, POSITIVE_INF),
        vec3(NEGATIVE_INF, NEGATIVE_INF, NEGATIVE_INF)
    );

    // Set parent pointers for child nodes (only for internal nodes, not leaves)
    if (!leftIsLeaf) {
        tree[split].parent = index_internal_nodes;
    } else {
        leftAABB = combineAABBs(
            leftAABB,
            surfelAABB(split)
        );
    }

    if (!rightIsLeaf) {
        tree[split + 1].parent = index_internal_nodes;
    } else {
        rightAABB = combineAABBs(
            rightAABB,
            surfelAABB(split + 1)
        );
    }

    const AABB combinedAABB = combineAABBs(leftAABB, rightAABB);

    tree[index_internal_nodes].min_x = combinedAABB.vMin.x;
    tree[index_internal_nodes].min_y = combinedAABB.vMin.y;
    tree[index_internal_nodes].min_z = combinedAABB.vMin.z;

    tree[index_internal_nodes].max_x = combinedAABB.vMax.x;
    tree[index_internal_nodes].max_y = combinedAABB.vMax.y;
    tree[index_internal_nodes].max_z = combinedAABB.vMax.z;

    // use tree_viewer.py to debug the bvh tree built by this compute shader
    //debugPrintfEXT(
    //    "node index %u -- parent: %u, left: %u, right: %u\n",
    //    index_internal_nodes,
    //    tree[index_internal_nodes].parent,
    //    tree[index_internal_nodes].left,
    //    tree[index_internal_nodes].right
    //);

    memoryBarrierBuffer();
}
