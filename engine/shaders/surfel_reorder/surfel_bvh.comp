#extension GL_EXT_debug_printf : enable

// This algorithm is a modified version of https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu

#include "../config.glsl"

// Keep in sync with SURFELS_BVH_GROUP_SIZE_X
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define SURFELS_DESCRIPTOR_SET 1
#include "../surfel.glsl"

// low is x, high is y
#define uint64_t uvec2
#define new_uint64_from_uint(u) uint64_t(u, 0)
#define new_uint64(low, high) uint64_t(low, high)

uint64_t rightShift(uint64_t value, uint shift) {
    if (shift >= 64) {
        return new_uint64_from_uint(0); // Shift out all bits
    } else if (shift >= 32) {
        // Shift high part into low part
        return new_uint64_from_uint(value.x >> (shift - 32));
    } else {
        // Shift low part and combine with high part
        uint newLow = (value.x >> shift) | (value.x << (32 - shift));
        uint newHigh = value.x >> shift;
        return new_uint64(newLow, newHigh);
    }
}

uint64_t leftShift(uint64_t value, uint shift) {
    if (shift >= 64) {
        return new_uint64_from_uint(0); // Shift out all bits
    } else if (shift >= 32) {
        return new_uint64(0, value.x << (shift - 32));
    } else {
        uint newLow = value.x << shift;
        uint newHigh = (value.y << shift) | (value.x >> (32 - shift));
        return new_uint64(newLow, newHigh);
    }
}

uint64_t bitwiseAnd(uint64_t a, uint64_t b) {
    return new_uint64(a.x & b.x, a.y & b.y);
}

uint64_t bitwiseXor(uint64_t a, uint64_t b) {
    return new_uint64(a.x ^ b.x, a.y ^ b.y);
}

uint64_t bitwiseOr(uint64_t a, uint64_t b) {
    return new_uint64(a.x | b.x, a.y | b.y);
}

// Fetch the number of splits in a given range of surfels:
// split happens when the next surfel changes a bit higher
int fetch_splits(uint start, uint size) {
    uint first_index = start;
    uint last_index = start + size - 1;

    uint morton_of_first = surfels[first_index].morton;
    uint morton_of_last = surfels[last_index].morton;

    uint morton_xor = morton_of_first ^ morton_of_last;
    if (morton_xor == 0) {
        return -1;
    }

    uint bit_changed = 0;
    for (uint b = 1u << 31; b != 0; b >>= 1) {
        if ((morton_xor & b) != 0) {
            bit_changed = b;
            break;
        }
    }

    uint lo = start;
    uint hi = start + size; // one-past-end
    uint tmp = (morton_of_first & bit_changed);
    while (lo < hi) {
        uint mid = lo + ((hi - lo) >> 1);
        uint v = surfels[mid].morton;

        bool diff = (v & bit_changed) != tmp;
        if (!diff) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }

/*
    // linar search of the first surfel that changes the interesting bit
    for (uint i = 0; i <= last_index; i++) {
        if ((surfels[i].morton & bit_changed) != (morton_of_first & bit_changed)) {
            return i;
        }
    }
*/
    return int(lo);
}

int delta(int i, int j, const uint surfels_count)
{
    if (((j < 0) || (j > surfels_count - 1)) || ((i < 0) || (i > surfels_count - 1)))
    {
        return -1;
    }

    const uint64_t key_i = new_uint64_from_uint(surfels[i].morton);
    const uint64_t key_j = new_uint64_from_uint(surfels[j].morton);

    const uint64_t composed_key_i = bitwiseOr(leftShift(key_i, 32), new_uint64_from_uint(i));
    const uint64_t composed_key_j = bitwiseOr(leftShift(key_j, 32), new_uint64_from_uint(j));

    const uint64_t x = bitwiseXor(composed_key_i, composed_key_j);

    int leading_zeroes = 0;
    for (int k = 63; k >= 0; --k) {
        if (bitwiseAnd(x, new_uint64_from_uint(0x01 << k)) == uint64_t(0)) {
            ++leading_zeroes;
        } else {
            return leading_zeroes;
        }
    }

    return leading_zeroes;
}

vec2 determineRange(const int index_internal_nodes, const uint numberOfTriangles)
{
    const int dleft = delta(index_internal_nodes, index_internal_nodes - 1, numberOfTriangles);
    const int dright = delta(index_internal_nodes, index_internal_nodes + 1, numberOfTriangles);

    // Determine direction of the range (+1 or -1)
    const int direction = sign(dright - dleft);

    // Compute upper bound for the length of the range
    const int delta_min = (direction == 1) ? dleft : dright;

    int l_max = 2;

    while (delta(index_internal_nodes, index_internal_nodes + l_max * direction, numberOfTriangles) > delta_min)
    {
        l_max *= 2;
    }

    int l = 0;

    // Find the other end using binary search
    for (int t = l_max / 2; t >= 1; t /= 2)
    {
        if (delta(index_internal_nodes, index_internal_nodes + (l + t) * direction, numberOfTriangles) > delta_min)
        {
            l += t;
        }
    }

    int j = index_internal_nodes + l * direction;

    return vec2(
        min(index_internal_nodes, j),
        max(index_internal_nodes, j)
    );
}

int findSplit(const int first, const int last, const uint count)
{
    const int commonPrefix = delta(first, last, count);

    int split = first;
    int step = last - first;

    do
    {
        step = (step + 1) >> 1;      // exponential decrease
        int newSplit = split + step; // proposed new position

        if (newSplit < last)
        {
            int splitPrefix = delta(first, newSplit, count);
            if (splitPrefix > commonPrefix)
                split = newSplit; // accept proposal
        }
    } while (step > 1);

    return split;
}

void main() {
    const uint index_internal_nodes = gl_GlobalInvocationID.x;

    const uint surfels_count = count_ordered_surfels();

    // initialize the root node as parent=0, left=0, right=0
    // if it is when needed it means the tree is empty.
    if (index_internal_nodes == 0) {
        tree[index_internal_nodes].parent = 0;
        tree[index_internal_nodes].left = 0;
        tree[index_internal_nodes].right = 0;
        memoryBarrierBuffer();
    }

    if (surfels_count == 0) {
        return;
    }

    // prepare the synchronization structure for the next step
    uint tmp = atomicMin(discovered[index_internal_nodes], 0);

    if (index_internal_nodes >= (surfels_count - 1)) {
        return;
    }

    const vec2 range = determineRange(int(index_internal_nodes), surfels_count);

    const int first_without_offset = int(range.x);
    const int last_without_offset = int(range.y);

    const int split_without_offset = findSplit(first_without_offset, last_without_offset, surfels_count);

    const uint split = split_without_offset;
    const uint first = uint(first_without_offset);
    const uint last = uint(last_without_offset);

    tree[index_internal_nodes].left = split;
    tree[index_internal_nodes].right = split + 1;

    // make sure the parent of a root node is the root node itself!
    if (index_internal_nodes == 0) {
        tree[index_internal_nodes].parent = index_internal_nodes;
    }

    AABB leftAABB = compatAABB(
        vec3(POSITIVE_INF, POSITIVE_INF, POSITIVE_INF),
        vec3(NEGATIVE_INF, NEGATIVE_INF, NEGATIVE_INF)
    );

    AABB rightAABB = compatAABB(
        vec3(POSITIVE_INF, POSITIVE_INF, POSITIVE_INF),
        vec3(NEGATIVE_INF, NEGATIVE_INF, NEGATIVE_INF)
    );

    // Output child pointers
    if (split != first)
    {
        // Update the parent node
        tree[split].parent = index_internal_nodes;
    } else {
        leftAABB = combineAABBs(
            leftAABB,
            surfelAABB(split)
        );

        // set to 1 the most significant bit: this is a leaf!
        tree[index_internal_nodes].left |= NODE_IS_LEAF_FLAG; 
    }

    if ((split + 1) != last)
    {
        // Update the parent node
        tree[split + 1].parent = index_internal_nodes;
    } else {
        rightAABB = combineAABBs(
            rightAABB,
            surfelAABB(split + 1)
        );

        // set to 1 the most significant bit: this is a leaf!
        tree[index_internal_nodes].right |= NODE_IS_LEAF_FLAG;
    }

    const AABB combinedAABB = combineAABBs(leftAABB, rightAABB);

    tree[index_internal_nodes].min_x = combinedAABB.vMin.x;
    tree[index_internal_nodes].min_y = combinedAABB.vMin.y;
    tree[index_internal_nodes].min_z = combinedAABB.vMin.z;

    tree[index_internal_nodes].max_x = combinedAABB.vMax.x;
    tree[index_internal_nodes].max_y = combinedAABB.vMax.y;
    tree[index_internal_nodes].max_z = combinedAABB.vMax.z;

    debugPrintfEXT(
        "node index %u -- parent: %u, left: %u, right: %u\n",
        index_internal_nodes,
        tree[index_internal_nodes].parent,
        tree[index_internal_nodes].left,
        tree[index_internal_nodes].right
    );

    memoryBarrierBuffer();
}
