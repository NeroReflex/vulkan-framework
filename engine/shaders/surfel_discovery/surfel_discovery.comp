#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_flags_primitive_culling : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_debug_printf : enable

#include "../config.glsl"
#include "../random.glsl"
#include "../math.glsl"
#include "../morton.glsl"

#define STATUS_DESCRIPTOR_SET 0
#include "../status.glsl"

#define GBUFFER_DESCRIPTOR_SET 1
#include "../gbuffer.glsl"

//#define SURFEL_IS_READONLY
#define BVH_IS_READONLY
#define SURFELS_DESCRIPTOR_SET 2
#include "../surfel.glsl"

// Keep in sync with SURFELS_DISCOVERY_GROUP_SIZE_X and SURFELS_DISCOVERY_GROUP_SIZE_Y
layout (local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

// Per-workgroup staging for surfel insertion
shared uint wgCandidates[gl_WorkGroupSize.x * gl_WorkGroupSize.y]; // flattened 2D local IDs
shared uint wgCount;    // number of valid compacted entries in wgCandidates
shared uint wgBase;     // base reserved index returned by atomicAdd

void main() {
    const ivec2 resolution = imageSize(outputImage[0]);

    const ivec2 texel_position = ivec2(gl_GlobalInvocationID.xy);

    // ================================
    // debug for the ordering to be correct
#if SHOW_SURFELS
    if (texel_position == uvec2(0, 0)) {
        const uint available_surfels = count_ordered_surfels();
        uint surfel_id = SURFELS_MISSED;
        uint last_morton = 0;
        for (uint i = 0; i < available_surfels; i++) {
            if (last_morton > surfels[i].morton) {
                // this should never happen
                debugPrintfEXT("MORTON SORT ERROR AT SURFEL %u %u > %u\n", i, last_morton, surfels[i].morton);
            }
        }
    }
#endif
    // ================================

    bool enabled = true;

    // avoid checking out-of-bounds
    if (any(greaterThanEqual(texel_position, resolution))) {
        enabled = false;
    }

    const vec3 origin = enabled ? texelFetch(gbuffer[0], texel_position, 0).xyz : vec3(0.0);

    const uvec4 instance_data = enabled ? texelFetch(gbuffer_instance_id, texel_position, 0) : uvec4(0xFFFFFFFFu);
    const uint mesh_id = instance_data.x;
    const uint instance_id = instance_data.y;

    if (mesh_id == 0xFFFFFFFFu) {
        // no geometry here
        enabled = false;
    }

    const vec2 clip_planes = reconstructNearFarFromCamera();
    const vec3 eye_position = get_eye_position();

    // try a fast search for surfels that have been allocated any older frame
    // because the shader that spawns surfels from the gbuffer has yet to be executed
    uint surfel_id = enabled ? bvh_search(origin) : 0xFFFFFFFFu;

    // ---------- Per-workgroup gather + single atomic reservation ----------
    // Each thread writes its candidate surfel id into wgCandidates at its local flattened index.
    uint localFlat = gl_LocalInvocationIndex; // flattened index within the workgroup
    uint candidate = surfel_id; // candidate to insert; could be SURFELS_MISSED in other cases
    wgCandidates[localFlat] = candidate;
    memoryBarrierShared();
    barrier();

    // Leader compacts + deduplicates the candidates into wgCandidates[0..wgCount-1]
    if (gl_LocalInvocationIndex == 0u) {
        uint writeIdx = 0u;
        uint WG_SIZE = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
        for (uint i = 0u; i < WG_SIZE; ++i) {
            uint v = wgCandidates[i];
            if (v == SURFELS_MISSED) continue;
            // dedupe within the workgroup
            bool dup = false;
            for (uint j = 0u; j < writeIdx; ++j) {
                if (wgCandidates[j] == v) { dup = true; break; }
            }
            if (!dup) {
                wgCandidates[writeIdx++] = v;
            }
        }
        wgCount = writeIdx;
    }
    memoryBarrierShared();
    barrier();

    uint myWgCount = wgCount;
    if ((myWgCount > 0u) && (enabled)) {
        // Leader reserves a contiguous block in the global discovered array
        if (gl_LocalInvocationIndex == 0u) {
            // atomicAdd returns the previous value; that is the base index for this group's block
            wgBase = atomicAdd(global_reserve_counter, myWgCount);
        }
        memoryBarrierShared();
    }
    barrier();

    uint base = wgBase;
    bool write_surfel = true;
    // If reservation would overflow, simply drop entries that don't fit
    if (enabled) {
        if (base >= MAX_USABLE_SURFELS) {
            write_surfel = false;
        }
    }

    // clamp to available capacity
    uint writable = myWgCount;
    if (base + writable > MAX_USABLE_SURFELS) {
        writable = MAX_USABLE_SURFELS - base;
    }

    // Each thread writes a subset of the compacted wgCandidates into the reserved global slots.
    if ((enabled) && (write_surfel)) {
        for (uint i = gl_LocalInvocationIndex; i < writable; i += gl_WorkGroupSize.x * gl_WorkGroupSize.y) {
            uint dst = base + i;
            uint val = wgCandidates[i];
            if (val == 0xFFFFFFFFu) {
                continue;
            }

            for (uint i = 0; i < MAX_USABLE_SURFELS; i++) {
                // we can proceed at attempting to add the surfel to the list of used surfels
                const uint old_value = atomicCompSwap(discovered[i], USED_SURFEL_MISSING, val);
                if (old_value == val) {
                    // my surfel was already discovered in another thread
                    break;
                } else if (old_value == USED_SURFEL_MISSING) {
                    // I successfully added my surfel to the list of discovered surfels
                    
                    // update the last time the surfel was used
                    surfels[surfel_id].latest_contribution = 0;
                    memoryBarrierBuffer();

                    atomicAdd(discovered_surfels, 1);

                    break;
                }
            }
            
            if (i == MAX_USABLE_SURFELS) {
                debugPrintfEXT("Reached maximum number of usable surfels on id(%u, %u)\n", gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
            }
        }
    }

    barrier();

    // --------------------------------------------------------------------

    if ((surfel_id != 0xFFFFFFFFu) && (enabled)) {
        // there is no surfel associated with this pixel
        imageStore(surfelOverlappingImage, texel_position, uvec4(surfel_id, 0, 0, 0));
    }
}
